<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mingshan Lei&#39;s Blog</title>
  
  <subtitle>雷鸣山的技术分享博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leicode.com/"/>
  <updated>2018-10-16T12:22:02.697Z</updated>
  <id>https://leicode.com/</id>
  
  <author>
    <name>Mingshan Lei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CAPTCHA简介与Java实现</title>
    <link href="https://leicode.com/posts/c8f51018/"/>
    <id>https://leicode.com/posts/c8f51018/</id>
    <published>2018-10-16T11:44:32.000Z</published>
    <updated>2018-10-16T12:22:02.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>CAPTCHA(Completely Automated Public Turing test to tell Computers and Humans Apart，简称CAPTCHA)，俗称验证码，是一种区分用户是计算机或人的公共全自动程序。在CAPTCHA测试中，作为服务器的计算机会自动生成一个问题由用户来解答。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。</p><p>目前验证码被广泛应用于网站登录、注册、防刷等处，用于识别和防止自动化程序恶意获取服务和数据。</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>目前大家常见的几类验证码有：</p><ul><li>标准验证码（图片），图片中一般是随机组合的字母和数字，对背景和内容进行扭曲，增加噪点和曲线，使程序难以识别</li><li>根据界面图形，进行鼠标、手指（移动端）交互操作（滑动拼图验证，点选验证）</li><li>No CAPTCHA （Google新一代reCAPTCHA，升级的风险分析技术可以智能无感知的判断人类与机器）</li><li>语音验证（播放一段音频给用户，用户获取信息后提交比对）</li><li>短信、邮箱验证<a id="more"></a></li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>采集用户所处环境信息以及操作信息，提交这些信息给后端服务器进行判断。<br>采集的信息多有：</p><ul><li>插件</li><li>User-agent</li><li>屏幕分辨率</li><li>在captcha的iframe中进行鼠标、键盘、触摸操作的次数和记录</li><li>渲染canvas图像</li><li>Cookies</li><li>用户输入内容</li></ul><p>服务端利用的技术，目前高端的验证码服务，大多会引入海量样本数据，引入深度学习来识别机器与人的行为模式。</p><p>Google的reCAPTCHA首先检测客户端环境，判断使用者是否处于人类的操作环境中。如果检测结果在容错范围内则直接通过测试，否则弹出验证码进行二次认证。</p><p>滑动验证的核心并不是简单的拼接成功就可以过，也不是简单的算一下偏移量就能破解。<br>新的滑块验证码方案，验证码后台针对用户产生的行为轨迹数据进行机器学习建模，结合访问频率、地理位置、历史记录等多个维度信息，快速、准确的返回人机判定结果。</p><p>滑动拼图验证码、图中点选验证码、智能无感知等，其背后的原理除了对滑块起始位置的认知、图中文字及其顺序的认知外，实际还会基于在页面上的操作行为、操作轨迹，以及当前设备的指纹、所运行的环境等维度进行大数据分析，并利用有监督和无监督的机器学习手段，不断升级和优化模型，不断提高破解的成本，保证人机识别的效果。</p><h1 id="验证码服务平台"><a href="#验证码服务平台" class="headerlink" title="验证码服务平台"></a>验证码服务平台</h1><p>极验验证 <a href="http://www.geetest.com/type/" target="_blank" rel="noopener">http://www.geetest.com/type/</a><br>网易云 易盾 <a href="http://dun.163.com/trial/sense" target="_blank" rel="noopener">http://dun.163.com/trial/sense</a><br>腾讯验证码 <a href="http://open.captcha.qq.com/cap_web/experience-slidepass.html" target="_blank" rel="noopener">http://open.captcha.qq.com/cap_web/experience-slidepass.html</a><br>Google reCAPTCHA <a href="https://www.google.com/recaptcha/intro/v3beta.html#" target="_blank" rel="noopener">https://www.google.com/recaptcha/intro/v3beta.html#</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;CAPTCHA(Completely Automated Public Turing test to tell Computers and Humans Apart，简称CAPTCHA)，俗称验证码，是一种区分用户是计算机或人的公共全自动程序。在CAPTCHA测试中，作为服务器的计算机会自动生成一个问题由用户来解答。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。&lt;/p&gt;&lt;p&gt;目前验证码被广泛应用于网站登录、注册、防刷等处，用于识别和防止自动化程序恶意获取服务和数据。&lt;/p&gt;&lt;h1 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h1&gt;&lt;p&gt;目前大家常见的几类验证码有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;标准验证码（图片），图片中一般是随机组合的字母和数字，对背景和内容进行扭曲，增加噪点和曲线，使程序难以识别&lt;/li&gt;&lt;li&gt;根据界面图形，进行鼠标、手指（移动端）交互操作（滑动拼图验证，点选验证）&lt;/li&gt;&lt;li&gt;No CAPTCHA （Google新一代reCAPTCHA，升级的风险分析技术可以智能无感知的判断人类与机器）&lt;/li&gt;&lt;li&gt;语音验证（播放一段音频给用户，用户获取信息后提交比对）&lt;/li&gt;&lt;li&gt;短信、邮箱验证
    
    </summary>
    
      <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="develop" scheme="https://leicode.com/tags/develop/"/>
    
      <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
      <category term="CAPTCHA" scheme="https://leicode.com/tags/CAPTCHA/"/>
    
  </entry>
  
  <entry>
    <title>docker attach的使用与正确退出</title>
    <link href="https://leicode.com/posts/7d17a93a/"/>
    <id>https://leicode.com/posts/7d17a93a/</id>
    <published>2018-10-16T06:41:31.000Z</published>
    <updated>2018-10-16T07:52:04.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sample-Dockerfile"><a href="#Sample-Dockerfile" class="headerlink" title="Sample Dockerfile"></a>Sample Dockerfile</h1><p>后面的讲解，以该Dockerfile构建的镜像为例说明。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jre-alpine</span><br><span class="line"></span><br><span class="line">MAINTAINER leimingshan</span><br><span class="line"></span><br><span class="line">ADD xxl-sso-server-0.1.1-SNAPSHOT.jar app.jar</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure><p></p><p>xxl-sso-server-0.1.1-SNAPSHOT.jar是Spring Boot打包生成的可执行jar，内嵌tomcat容器，直接使用java -jar启动内嵌<br>的tomcat容器并监听8080端口，这里是最简单的一种制作Spring Boot程序镜像的方法，java -jar就是容器内的主进程，如果该<br>进程终止，容器也就相应退出。</p><p>另外一种常见的镜像制作方法，就是加入supervisor来管理进程，稍微重一些，适合管理容器内的多个进程，此时，java等进程是supervisord的子进程，Dockerfile中的命令也要变成<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;/usr/bin/supervisord&quot;, &quot;-n&quot;, &quot;-c&quot;, &quot;/etc/supervisord.conf&quot;]</span><br></pre></td></tr></table></figure><p></p><p>supervisord也是容器内的进程命令，只要supervisord不退出，容器就不会退出。</p><p>Spring Boot相关的内容大家可以自行学习下，这里就不详述了。</p><h1 id="Detached-vs-foreground"><a href="#Detached-vs-foreground" class="headerlink" title="Detached vs foreground"></a>Detached vs foreground</h1><p>Docker run命令运行一个容器的时候，有一个-d选项</p><blockquote><blockquote><p>-d=false: Detached mode: Run container in the background, print new container id</p></blockquote></blockquote><p>detached的意思是让容器在后台运行，同时与你当前终端的STDIN，STDOUT，STDERR分离，然后告诉你一个容器id。<br>执行该命令之后，我们只会看到一个容器id。</p><p>默认不指定-d选项的时候，即-d=false，容器在前台运行，此时容器<br>处于attached状态，或者说是foreground前台模式，容器内进程（一般是ENTRYPOINT指定的运行命令）的STDIN，STDOUT，STDERR<br>会与你当前的命令行终端连接，你就可以直接看到容器内进程执行时候的输出，而你的输入也会重定向到容器内进程。以示例镜像运行产生的容器来说，你的所有输入输出都是和java -jar进程关联的。</p><p>参考：<a href="https://docs.docker.com/engine/reference/run/#detached-vs-foreground" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/run/#detached-vs-foreground</a><br><a id="more"></a></p><h1 id="docker-attach-command"><a href="#docker-attach-command" class="headerlink" title="docker attach command"></a>docker attach command</h1><p>attach命令可以让你attach到一个处于detached状态的容器。<br>以示例来说，我们会重新连接到java -jar进程的输入输出，看到该进程打印到STDOUT和STDERR的内容，如果此时，你属于了CTRL-c，也就是SIGKILL信号会发送给容器，java进程退出，容器也相应退出。</p><p>此处往往让大家感到困惑，我也遇到了这个问题。大多数情况下，我们按CTRL-c，是想结束docker attach这个进程，并不是想结束我们正在运行的attach到的这个容器啊。我们还是想让容器继续运行的呀。</p><p>官方文档说，CTRL-p CTRL-q 按键序列可以实现这个功能啊，其实就是同时按CTRL+p+q，但我发现没用啊。<br>此时我们想detach容器，使容器重新回到detached状态，我这边却无法实现。</p><p>重点来了：<br><a href="https://stackoverflow.com/questions/20145717/how-to-detach-from-a-docker-container" target="_blank" rel="noopener">https://stackoverflow.com/questions/20145717/how-to-detach-from-a-docker-container</a></p><p>docker run -t -i → can be detached with ^P^Q and reattached with docker attach<br>docker run -i → cannot be detached with ^P^Q; will disrupt stdin<br>docker run → cannot be detached with ^P^Q; can SIGKILL client; can reattach with docker attach</p><p>参考：<a href="https://docs.docker.com/engine/reference/commandline/attach/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/attach/</a></p><p>这里就很明显的，只有在run的时候用了-it，才可以用CTRL-p CTRL-q的按键序列进行detach。</p><p>原因是什么呢，这里就涉及到tty和docker tty的许多知识了，后面的文章再详细解释吧。</p><h1 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h1><p>想看到容器的STDOUT和STDERR，并不需要attach到容器上，docker logs命令完全可以满足需求。</p><p>参考：<a href="https://docs.docker.com/engine/reference/commandline/logs/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/logs/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Sample-Dockerfile&quot;&gt;&lt;a href=&quot;#Sample-Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;Sample Dockerfile&quot;&gt;&lt;/a&gt;Sample Dockerfile&lt;/h1&gt;&lt;p&gt;后面的讲解，以该Dockerfile构建的镜像为例说明。&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FROM openjdk:8-jre-alpine&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MAINTAINER leimingshan&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ADD xxl-sso-server-0.1.1-SNAPSHOT.jar app.jar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EXPOSE 8080&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ENTRYPOINT [&amp;quot;java&amp;quot;,&amp;quot;-jar&amp;quot;,&amp;quot;/app.jar&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;xxl-sso-server-0.1.1-SNAPSHOT.jar是Spring Boot打包生成的可执行jar，内嵌tomcat容器，直接使用java -jar启动内嵌&lt;br&gt;的tomcat容器并监听8080端口，这里是最简单的一种制作Spring Boot程序镜像的方法，java -jar就是容器内的主进程，如果该&lt;br&gt;进程终止，容器也就相应退出。&lt;/p&gt;&lt;p&gt;另外一种常见的镜像制作方法，就是加入supervisor来管理进程，稍微重一些，适合管理容器内的多个进程，此时，java等进程是supervisord的子进程，Dockerfile中的命令也要变成&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ENTRYPOINT [&amp;quot;/usr/bin/supervisord&amp;quot;, &amp;quot;-n&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;/etc/supervisord.conf&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;supervisord也是容器内的进程命令，只要supervisord不退出，容器就不会退出。&lt;/p&gt;&lt;p&gt;Spring Boot相关的内容大家可以自行学习下，这里就不详述了。&lt;/p&gt;&lt;h1 id=&quot;Detached-vs-foreground&quot;&gt;&lt;a href=&quot;#Detached-vs-foreground&quot; class=&quot;headerlink&quot; title=&quot;Detached vs foreground&quot;&gt;&lt;/a&gt;Detached vs foreground&lt;/h1&gt;&lt;p&gt;Docker run命令运行一个容器的时候，有一个-d选项&lt;/p&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;-d=false: Detached mode: Run container in the background, print new container id&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p&gt;detached的意思是让容器在后台运行，同时与你当前终端的STDIN，STDOUT，STDERR分离，然后告诉你一个容器id。&lt;br&gt;执行该命令之后，我们只会看到一个容器id。&lt;/p&gt;&lt;p&gt;默认不指定-d选项的时候，即-d=false，容器在前台运行，此时容器&lt;br&gt;处于attached状态，或者说是foreground前台模式，容器内进程（一般是ENTRYPOINT指定的运行命令）的STDIN，STDOUT，STDERR&lt;br&gt;会与你当前的命令行终端连接，你就可以直接看到容器内进程执行时候的输出，而你的输入也会重定向到容器内进程。以示例镜像运行产生的容器来说，你的所有输入输出都是和java -jar进程关联的。&lt;/p&gt;&lt;p&gt;参考：&lt;a href=&quot;https://docs.docker.com/engine/reference/run/#detached-vs-foreground&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/engine/reference/run/#detached-vs-foreground&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="docker" scheme="https://leicode.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Java Unsafe的应用与发展</title>
    <link href="https://leicode.com/posts/7d6ac8a1/"/>
    <id>https://leicode.com/posts/7d6ac8a1/</id>
    <published>2018-10-09T06:01:29.000Z</published>
    <updated>2018-10-09T07:37:57.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>sun.misc.Unsafe至少从2004年Java1.4开始就存在于Java中了。<br>在Java9发布之前，有传闻说Oracle会在Java9正式发布时移除sun.misc.Unsafe，引起了激烈的争论。<br>因为有不少重要的Java开发库都在底层使用了sum.misc.Unsafe，例如Netty，Neo4J，Spring Framework，Apache Kafka，Apache Storm等。<br>新的替代API成熟之前，直接移除Unsafe是很冒险的一项做法。</p><p><a href="http://openjdk.java.net/jeps/260" target="_blank" rel="noopener">JEP 260</a>是Java9中一项重要内容，意在封装那些JDK内部使用的API，而不再提供给外部应用使用。<br>鉴于类似Unsafe这类非常关键而广泛使用的API，目前也没有非常有效的替代方案，暂时得到了保留，因此在JDK9中，我们仍然可以使用Unsafe类，目前没有被内部封装。<br>在JDK9中jdk.internal.misc中也可以找到Unsafe类。</p><p>JDK9中没有被封装的关键内部类有：</p><ul><li>sun.misc.{Signal,SignalHandler}</li><li>sun.misc.Unsafe （许多功能可以通过variable handles实现，后面介绍）</li><li>sun.reflect.ReflectionFactory</li><li>com.sun.nio.file.{ExtendedCopyOption,ExtendedOpenOption, ExtendedWatchEventModifier,SensitivityWatchEventModifier}</li></ul><p>这些类在以后的版本中可能被移除或封装。而非关键类例如sun.misc.BASE64Encoder和sun.misc.BASE64Decoder则直接被移除了。<br><a id="more"></a></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>Unsafe类名的意思就是“不安全的”，警告开发者们一定要慎重使用该类。</p><p>我们知道，Java语言是不能直接访问底层硬件的，但为了解决某些问题，还不得不访问底层硬件，Java提供了JNI技术（JNI是Java Native Interface的缩写，它提供了若干的API实现了Java和其他语言的通信）使我们可以通过C、C++这类语言去访问底层硬件。</p><p>Unsafe类通过JNI封装了一些较为底层的方法，但就如它的类名表达的含义一样，警告使用者使用它里面的方法是不安全的、是很危险的。使用Unsafe直接操作内存，是绕过了JVM的内存分配机制的，需要自己手动分配回收内存（熟悉C语言的同学一定很熟悉），以及内存屏障（store load barrier）和CAS这些操作，都是非常危险的操作。所以默认情况下，Unsafe只提供给可信任代码（被BootstrapClassLoader加载的类，也就是说只能被rt.jar包里面的类）使用。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>开发者自己编写的类是由AppClassLoader加载的，如果尝试调用Unsafe.getUnsafe()来获得Unsafe的实例的话，你会遇到一个SecurityException的异常，因为前面提到，只有可信任代码（例如JDK中的Atomic相关类）才能这样直接获取Unsafe实例。<br>JDK8之前只能通过反射获取实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">f.setAccessible(true);</span><br><span class="line">Unsafe unsafe = (Unsafe) f.get(null);</span><br></pre></td></tr></table></figure><p></p><p>JDK9中其实已经没有了上述限制，参考Unsafe源码对比。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package jdk.internal.misc;</span><br><span class="line"></span><br><span class="line">import jdk.internal.HotSpotIntrinsicCandidate;</span><br><span class="line">import jdk.internal.vm.annotation.ForceInline;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> */</span><br><span class="line">public final class Unsafe &#123;</span><br><span class="line"></span><br><span class="line">    private static native void registerNatives();</span><br><span class="line">    static &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Unsafe() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static final Unsafe theUnsafe = new Unsafe();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Provides the caller with the capability of performing unsafe</span><br><span class="line">     * operations.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The returned &#123;@code Unsafe&#125; object should be carefully guarded</span><br><span class="line">     * by the caller, since it can be used to read and write data at arbitrary</span><br><span class="line">     * memory addresses.  It must never be passed to untrusted code.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Most methods in this class are very low-level, and correspond to a</span><br><span class="line">     * small number of hardware instructions (on typical machines).  Compilers</span><br><span class="line">     * are encouraged to optimize these methods accordingly.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Here is a suggested idiom for using unsafe operations:</span><br><span class="line">     *</span><br><span class="line">     * &lt;pre&gt; &#123;@code</span><br><span class="line">     * class MyTrustedClass &#123;</span><br><span class="line">     *   private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">     *   ...</span><br><span class="line">     *   private long myCountAddress = ...;</span><br><span class="line">     *   public int getCount() &#123; return unsafe.getByte(myCountAddress); &#125;</span><br><span class="line">     * &#125;&#125;&lt;/pre&gt;</span><br><span class="line">     *</span><br><span class="line">     * (It may assist compilers to make the local variable &#123;@code final&#125;.)</span><br><span class="line">     */</span><br><span class="line">    public static Unsafe getUnsafe() &#123;</span><br><span class="line">        return theUnsafe;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>JDK1.9之前的sun.misc.Unsafe<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package sun.misc;</span><br><span class="line"></span><br><span class="line">import jdk.internal.vm.annotation.ForceInline;</span><br><span class="line">import jdk.internal.misc.VM;</span><br><span class="line">import jdk.internal.ref.Cleaner;</span><br><span class="line">import jdk.internal.reflect.CallerSensitive;</span><br><span class="line">import jdk.internal.reflect.Reflection;</span><br><span class="line">import sun.nio.ch.DirectBuffer;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public final class Unsafe &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Reflection.registerMethodsToFilter(Unsafe.class, &quot;getUnsafe&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Unsafe() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static final Unsafe theUnsafe = new Unsafe();</span><br><span class="line">    private static final jdk.internal.misc.Unsafe theInternalUnsafe = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Provides the caller with the capability of performing unsafe</span><br><span class="line">     * operations.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The returned &#123;@code Unsafe&#125; object should be carefully guarded</span><br><span class="line">     * by the caller, since it can be used to read and write data at arbitrary</span><br><span class="line">     * memory addresses.  It must never be passed to untrusted code.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Most methods in this class are very low-level, and correspond to a</span><br><span class="line">     * small number of hardware instructions (on typical machines).  Compilers</span><br><span class="line">     * are encouraged to optimize these methods accordingly.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Here is a suggested idiom for using unsafe operations:</span><br><span class="line">     *</span><br><span class="line">     * &lt;pre&gt; &#123;@code</span><br><span class="line">     * class MyTrustedClass &#123;</span><br><span class="line">     *   private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">     *   ...</span><br><span class="line">     *   private long myCountAddress = ...;</span><br><span class="line">     *   public int getCount() &#123; return unsafe.getByte(myCountAddress); &#125;</span><br><span class="line">     * &#125;&#125;&lt;/pre&gt;</span><br><span class="line">     *</span><br><span class="line">     * (It may assist compilers to make the local variable &#123;@code final&#125;.)</span><br><span class="line">     *</span><br><span class="line">     * @throws  SecurityException if the class loader of the caller</span><br><span class="line">     *          class is not in the system domain in which all permissions</span><br><span class="line">     *          are granted.</span><br><span class="line">     */</span><br><span class="line">    @CallerSensitive</span><br><span class="line">    public static Unsafe getUnsafe() &#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        if (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">            throw new SecurityException(&quot;Unsafe&quot;);</span><br><span class="line">        return theUnsafe;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="未来的替代者Variable-Handles"><a href="#未来的替代者Variable-Handles" class="headerlink" title="未来的替代者Variable Handles"></a>未来的替代者Variable Handles</h1><p><a href="https://www.voxxed.com/2016/11/java-9-series-variable-handles/" target="_blank" rel="noopener">https://www.voxxed.com/2016/11/java-9-series-variable-handles/</a><br>java.lang.invoke.VarHandle</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://www.jianshu.com/p/54cc20a87502" target="_blank" rel="noopener">https://www.jianshu.com/p/54cc20a87502</a><br><a href="https://blog.csdn.net/luzheqi/article/details/79097682" target="_blank" rel="noopener">https://blog.csdn.net/luzheqi/article/details/79097682</a><br><a href="http://ifeve.com/java-9-sun-misc-unsafe/comment-page-1/" target="_blank" rel="noopener">http://ifeve.com/java-9-sun-misc-unsafe/comment-page-1/</a><br><a href="https://www.zybuluo.com/kiraSally/note/867462" target="_blank" rel="noopener">https://www.zybuluo.com/kiraSally/note/867462</a><br><a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-F7696E02-A1FB-4D5A-B1F2-89E7007D4096" target="_blank" rel="noopener">https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-F7696E02-A1FB-4D5A-B1F2-89E7007D4096</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;历史&quot;&gt;&lt;a href=&quot;#历史&quot; class=&quot;headerlink&quot; title=&quot;历史&quot;&gt;&lt;/a&gt;历史&lt;/h1&gt;&lt;p&gt;sun.misc.Unsafe至少从2004年Java1.4开始就存在于Java中了。&lt;br&gt;在Java9发布之前，有传闻说Oracle会在Java9正式发布时移除sun.misc.Unsafe，引起了激烈的争论。&lt;br&gt;因为有不少重要的Java开发库都在底层使用了sum.misc.Unsafe，例如Netty，Neo4J，Spring Framework，Apache Kafka，Apache Storm等。&lt;br&gt;新的替代API成熟之前，直接移除Unsafe是很冒险的一项做法。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://openjdk.java.net/jeps/260&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JEP 260&lt;/a&gt;是Java9中一项重要内容，意在封装那些JDK内部使用的API，而不再提供给外部应用使用。&lt;br&gt;鉴于类似Unsafe这类非常关键而广泛使用的API，目前也没有非常有效的替代方案，暂时得到了保留，因此在JDK9中，我们仍然可以使用Unsafe类，目前没有被内部封装。&lt;br&gt;在JDK9中jdk.internal.misc中也可以找到Unsafe类。&lt;/p&gt;&lt;p&gt;JDK9中没有被封装的关键内部类有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;sun.misc.{Signal,SignalHandler}&lt;/li&gt;&lt;li&gt;sun.misc.Unsafe （许多功能可以通过variable handles实现，后面介绍）&lt;/li&gt;&lt;li&gt;sun.reflect.ReflectionFactory&lt;/li&gt;&lt;li&gt;com.sun.nio.file.{ExtendedCopyOption,ExtendedOpenOption, ExtendedWatchEventModifier,SensitivityWatchEventModifier}&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这些类在以后的版本中可能被移除或封装。而非关键类例如sun.misc.BASE64Encoder和sun.misc.BASE64Decoder则直接被移除了。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK11已正式发布</title>
    <link href="https://leicode.com/posts/df008f1/"/>
    <id>https://leicode.com/posts/df008f1/</id>
    <published>2018-09-29T03:01:11.000Z</published>
    <updated>2018-09-29T08:13:08.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正式发布"><a href="#正式发布" class="headerlink" title="正式发布"></a>正式发布</h1><p>9月25日，Oracle官方宣布Java11(18.9 LTS)正式发布，可在生产环境中使用！<br>Java11是Oracle在2017年宣布新的JDK发布时间表之后，第一个长期支持 - Long Term Support(LTS)版本，非常值得大家关注。<br>如果说之前的Java9和Java10关注度都比较小，基本都被大家忽略的话，Java11可是绝对不容错过的。<br>作为新版发布路线的第一个LTS版本，其重要性和对后面版本的影响都不言而喻，<br>Oracle直到2023年9月都会为Java 11提供技术支持，而补丁和安全警告等扩展支持将持续到2026年。<br>LTS版本每三年发布一次，根据后续的发布计划，下一个LTS版本，应该是Java17，要在3年后的2021年才会与大家见面。</p><p>为了更快地迭代，以及跟进社区反馈，自2018年起，Java的版本发布周期变更为每六个月一次 —— 每半年发布一个大版本，每个季度发布一个中间特性版本，并且承诺不会跳票。<br>通过这样的方式，开发团队可以把一些关键特性尽早合并到JDK之中，以快速得到开发者反馈，在一定程度上避免出现像Java 9这样两次被迫延迟发布的窘况。</p><p>按照官方的说法，新的发布周期会严格遵循时间点，将于每年的3月份和9月份发布。所以Java 11的版本号是18.9(LTS)。</p><p>不过与Java 9和Java 10这两个被称为“功能性版本”不同（两者均只提供半年的技术支持），Java 11不仅提供了长期支持服务，还将作为Java平台的参考实现，并技术支持到2023年9月。</p><a id="more"></a><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html</a> Oracle的商业许可<br><a href="http://jdk.java.net/11" target="_blank" rel="noopener">http://jdk.java.net/11</a> OpenJDK, GPLv2 with the Classpath Exception</p><h1 id="License"><a href="#License" class="headerlink" title="License"></a>License</h1><p>在Oracle JDK11的下载页面，有明显的提示信息，指出了Oracle JDK11的<a href="https://www.oracle.com/technetwork/java/javase/terms/license/javase-license.html" target="_blank" rel="noopener">许可证</a>情况，需要注意的是</p><blockquote><blockquote><p>You may not:<br>use the Programs for any data processing or any commercial, production, or internal business purposes other than developing, testing, prototyping, and demonstrating your Application;</p></blockquote></blockquote><p>不允许进行数据处理、商用或在产线使用。只可以用于开发、测试、原型、和应用的演示用途。Oracle JDK已经是商业版本，不是随意免费使用的，若要用在产线环境，需要取得相应授权。</p><p>OpenJDK版本应该是基于GPLv2许可的，也是许多Linux发行版默认使用的，看来以后要拥抱OpenJDK了。</p><h1 id="技术文档"><a href="#技术文档" class="headerlink" title="技术文档"></a>技术文档</h1><p><a href="https://docs.oracle.com/en/java/javase/11/" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/11/</a></p><h1 id="版本支持情况"><a href="#版本支持情况" class="headerlink" title="版本支持情况"></a>版本支持情况</h1><p>Oracle Java SE的支持路线图，感兴趣的同学可以在<a href="https://www.oracle.com/technetwork/java/javase/eol-135779.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/eol-135779.html</a> 查看。<br>对于普通用户和Oracle的商业客户都有些区别，简单了解下就好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;正式发布&quot;&gt;&lt;a href=&quot;#正式发布&quot; class=&quot;headerlink&quot; title=&quot;正式发布&quot;&gt;&lt;/a&gt;正式发布&lt;/h1&gt;&lt;p&gt;9月25日，Oracle官方宣布Java11(18.9 LTS)正式发布，可在生产环境中使用！&lt;br&gt;Java11是Oracle在2017年宣布新的JDK发布时间表之后，第一个长期支持 - Long Term Support(LTS)版本，非常值得大家关注。&lt;br&gt;如果说之前的Java9和Java10关注度都比较小，基本都被大家忽略的话，Java11可是绝对不容错过的。&lt;br&gt;作为新版发布路线的第一个LTS版本，其重要性和对后面版本的影响都不言而喻，&lt;br&gt;Oracle直到2023年9月都会为Java 11提供技术支持，而补丁和安全警告等扩展支持将持续到2026年。&lt;br&gt;LTS版本每三年发布一次，根据后续的发布计划，下一个LTS版本，应该是Java17，要在3年后的2021年才会与大家见面。&lt;/p&gt;&lt;p&gt;为了更快地迭代，以及跟进社区反馈，自2018年起，Java的版本发布周期变更为每六个月一次 —— 每半年发布一个大版本，每个季度发布一个中间特性版本，并且承诺不会跳票。&lt;br&gt;通过这样的方式，开发团队可以把一些关键特性尽早合并到JDK之中，以快速得到开发者反馈，在一定程度上避免出现像Java 9这样两次被迫延迟发布的窘况。&lt;/p&gt;&lt;p&gt;按照官方的说法，新的发布周期会严格遵循时间点，将于每年的3月份和9月份发布。所以Java 11的版本号是18.9(LTS)。&lt;/p&gt;&lt;p&gt;不过与Java 9和Java 10这两个被称为“功能性版本”不同（两者均只提供半年的技术支持），Java 11不仅提供了长期支持服务，还将作为Java平台的参考实现，并技术支持到2023年9月。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>自建Git服务的几个选择</title>
    <link href="https://leicode.com/posts/a9253739/"/>
    <id>https://leicode.com/posts/a9253739/</id>
    <published>2018-09-12T07:38:51.000Z</published>
    <updated>2018-09-29T03:03:04.310Z</updated>
    
    <content type="html"><![CDATA[<p>两年前比较早的时候，git刚流行起来，私服方案记得只有一个，就是gitlab，gitlab自己提供累死github的公有服务器，也提供自己搭建<br>服务的功能，现在官方还有了docker image，可以说是非常方便了。</p><p>Gitlab的特点：</p><ul><li>优点：功能很全，自带CI持续集成和Issue tracking。</li><li>缺点：比较重，配置要求高。建议独立部署，内存需求比较大。</li></ul><p>最近偶尔看到了几个非常轻量的自建git服务，这里简单记录一下，以后也许会用得到：</p><ol><li>Gogs。<a href="https://gogs.io/。GO语言开发，跨平台，支持docker。" target="_blank" rel="noopener">https://gogs.io/。GO语言开发，跨平台，支持docker。</a></li><li>Gitea。Gogs的社区开发维护版本。<a href="https://gitea.io/zh-cn/。" target="_blank" rel="noopener">https://gitea.io/zh-cn/。</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两年前比较早的时候，git刚流行起来，私服方案记得只有一个，就是gitlab，gitlab自己提供累死github的公有服务器，也提供自己搭建&lt;br&gt;服务的功能，现在官方还有了docker image，可以说是非常方便了。&lt;/p&gt;&lt;p&gt;Gitlab的特点：&lt;/p&gt;&lt;ul&gt;&lt;
      
    
    </summary>
    
      <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="git" scheme="https://leicode.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo进阶设置</title>
    <link href="https://leicode.com/posts/a62b0c3d/"/>
    <id>https://leicode.com/posts/a62b0c3d/</id>
    <published>2018-09-07T08:21:04.000Z</published>
    <updated>2018-09-29T03:03:58.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态代码压缩"><a href="#静态代码压缩" class="headerlink" title="静态代码压缩"></a>静态代码压缩</h1><p>因为Blog中都是静态页面，基本都可以压缩优化，针对html，css，js，图片进行。<br>这里没必要用gulp去压缩，配置太繁琐，也没法自动化。<br>直接使用<a href="https://github.com/chenzhutian/hexo-all-minifier" target="_blank" rel="noopener">hexo-all-minifier</a>这个模块，<br>安装：</p><blockquote><p>npm install hexo-all-minifier –save</p></blockquote><p>增加配置：</p><blockquote><p>all_minifier: true</p></blockquote><p>搞定！</p><h1 id="文章唯一链接"><a href="#文章唯一链接" class="headerlink" title="文章唯一链接"></a>文章唯一链接</h1><p>hexo-abbrlink</p><h1 id="文章字数统计和阅读时长"><a href="#文章字数统计和阅读时长" class="headerlink" title="文章字数统计和阅读时长"></a>文章字数统计和阅读时长</h1><p><a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">hexo-symbols-count-time</a><br>可以替代老的hexo-wordcount。</p><h1 id="SEO-搜索引擎收录和优化"><a href="#SEO-搜索引擎收录和优化" class="headerlink" title="SEO-搜索引擎收录和优化"></a>SEO-搜索引擎收录和优化</h1><p>利用插件生成sitemap，hexo自带的两个插件，百度搜索要使用单独的一个。<br><a id="more"></a><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save     </span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p></p><p>修改根目录中的_config.yml，url必须要修改成对应的，会体现在sitemap.xml里的url里。增加配置项。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p></p><p>之后hexo重新生成部署，就可以看到两个站点地图的xml文件了。</p><h2 id="Google收录"><a href="#Google收录" class="headerlink" title="Google收录"></a>Google收录</h2><p>Google站点平台：<a href="https://www.google.com/webmasters/" target="_blank" rel="noopener">https://www.google.com/webmasters/</a><br>验证站点可以用html文件的方式，html文件放在hexo的source目录后，一定要在开头添加<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p></p><p>这样hexo才可以正确处理该文件。</p><p>之后提交sitemap即可，配置比较简单，不再赘述。</p><p>参考资料：</p><ul><li><a href="http://muyunyun.cn/posts/f55182c5/" target="_blank" rel="noopener">http://muyunyun.cn/posts/f55182c5/</a></li><li><a href="https://blog.csdn.net/sunshine940326/article/details/70936988" target="_blank" rel="noopener">https://blog.csdn.net/sunshine940326/article/details/70936988</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;静态代码压缩&quot;&gt;&lt;a href=&quot;#静态代码压缩&quot; class=&quot;headerlink&quot; title=&quot;静态代码压缩&quot;&gt;&lt;/a&gt;静态代码压缩&lt;/h1&gt;&lt;p&gt;因为Blog中都是静态页面，基本都可以压缩优化，针对html，css，js，图片进行。&lt;br&gt;这里没必要用gulp去压缩，配置太繁琐，也没法自动化。&lt;br&gt;直接使用&lt;a href=&quot;https://github.com/chenzhutian/hexo-all-minifier&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo-all-minifier&lt;/a&gt;这个模块，&lt;br&gt;安装：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;npm install hexo-all-minifier –save&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;增加配置：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;all_minifier: true&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;搞定！&lt;/p&gt;&lt;h1 id=&quot;文章唯一链接&quot;&gt;&lt;a href=&quot;#文章唯一链接&quot; class=&quot;headerlink&quot; title=&quot;文章唯一链接&quot;&gt;&lt;/a&gt;文章唯一链接&lt;/h1&gt;&lt;p&gt;hexo-abbrlink&lt;/p&gt;&lt;h1 id=&quot;文章字数统计和阅读时长&quot;&gt;&lt;a href=&quot;#文章字数统计和阅读时长&quot; class=&quot;headerlink&quot; title=&quot;文章字数统计和阅读时长&quot;&gt;&lt;/a&gt;文章字数统计和阅读时长&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/theme-next/hexo-symbols-count-time&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo-symbols-count-time&lt;/a&gt;&lt;br&gt;可以替代老的hexo-wordcount。&lt;/p&gt;&lt;h1 id=&quot;SEO-搜索引擎收录和优化&quot;&gt;&lt;a href=&quot;#SEO-搜索引擎收录和优化&quot; class=&quot;headerlink&quot; title=&quot;SEO-搜索引擎收录和优化&quot;&gt;&lt;/a&gt;SEO-搜索引擎收录和优化&lt;/h1&gt;&lt;p&gt;利用插件生成sitemap，hexo自带的两个插件，百度搜索要使用单独的一个。&lt;br&gt;
    
    </summary>
    
      <category term="网站" scheme="https://leicode.com/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="web" scheme="https://leicode.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>JDK11-ZGC</title>
    <link href="https://leicode.com/posts/769720f0/"/>
    <id>https://leicode.com/posts/769720f0/</id>
    <published>2018-09-03T05:52:32.000Z</published>
    <updated>2018-10-09T05:56:16.520Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 11即将于09/25正式发布，包含了诸多新的特性，主要的新特性JEP(JDK Enhancement Proposal 特性增强提议)有17个，参见下表</p><ul><li>181: Nest-Based Access Control</li><li>309: Dynamic Class-File Constants</li><li>315: Improve Aarch64 Intrinsics</li><li>318: Epsilon: A No-Op Garbage Collector</li><li>320: Remove the Java EE and CORBA Modules</li><li>321: HTTP Client (Standard)</li><li>323: Local-Variable Syntax for Lambda Parameters</li><li>324: Key Agreement with Curve25519 and Curve448</li><li>327: Unicode 10</li><li>328: Flight Recorder</li><li>329: ChaCha20 and Poly1305 Cryptographic Algorithms</li><li>330: Launch Single-File Source-Code Programs</li><li>331: Low-Overhead Heap Profiling</li><li>332: Transport Layer Security (TLS) 1.3</li><li>333: ZGC: A Scalable Low-Latency Garbage Collector(Experimental)</li><li>335: Deprecate the Nashorn JavaScript Engine</li><li>336: Deprecate the Pack200 Tools and API</li></ul><p>其中，非常值得大家关注的是JEP-333，ZGC，一个可扩展的低延迟垃圾回收器。ZGC目前仍处于实验阶段，不建议在生产环境使用。<br>目前使用ZGC需要添加JVM参数：-XX:+UnlockExperimentalVMOptions -XX:+UseZGC<br><a id="more"></a></p><p>ZGC的目标：</p><ul><li>GC停顿(Stop the wordld)时间不会超过10ms</li><li>能够处理从几百MB到几TB大小的JAVA堆</li><li>与G1相比，吞吐量下降不超过15%</li><li>为未来的GC功能和优化利用有色对象指针(colored oops)和加载屏障(load barriers)奠定基础</li><li>初始只支持Linux/x64</li></ul><p>ZGC可以并发执行以下GC任务/阶段：</p><ul><li>标记（Marking）</li><li>引用处理（Reference processing）</li><li>重新分配集的选择（Relocation set selection）</li><li>重分配/压缩（Relocation/Compaction）</li></ul><p>ZGC的特点描述：</p><ul><li>concurrent</li><li>single-generation</li><li>region-based</li><li>NUMA-aware</li></ul><p>GC是Java的主要优势之一。然而，当GC停顿太长，就会开始影响应用的响应时间。消除或者减少GC停顿时长，Java将在更广泛的应用场景中成为一个更有吸引力的平台。<br>此外，现代操作系统中可用内存不断增长，用户和程序员都希望JVM能够以高效的方式充分利用这些内存，并且无需长时间的GC暂停时间。</p><p>ZGC一个并发，基于region，压缩型的垃圾收集器，只有root扫描阶段会STW，因此GC停顿时间不会随着堆的增长和存活对象的增长而变长。</p><p>ZGC的核心设计原则是使用负载屏障（load barrier）与有色指针对象（colored object pointers，colored oops）组合。这使得ZGC能够进行并发操作，比如对象的重定位，Java应用程序线程正在运行时，从Java线程的角度，在Java对象中加载引用字段的行为是会受到负载障碍的影响。除了对象地址以外，有色对象指针包含负载障碍所需的其他信息，用来确定Java线程在使用指针之前是否需要执行某些操作，例如，该对象可能已被重新定位，负载屏障将检测到这种情况并采取合适的行为。</p><p>A core design principle/choice in ZGC is the use of load barriers in combination with colored object pointers (i.e., colored oops). This is what enables ZGC to do concurrent operations, such as object relocation, while Java application threads are running. From a Java thread’s perspective, the act of loading a reference field in a Java object is subject to a load barrier. In addition to an object address, a colored object pointer contains information used by the load barrier to determine if some action needs to be taken before allowing a Java thread to use the pointer. For example, the object might have been relocated, in which case the load barrier will detect the situation and take appropriate action.</p><p>参考文档：<br><a href="http://openjdk.java.net/projects/jdk/11/" target="_blank" rel="noopener">JDK 11</a><br><a href="http://openjdk.java.net/jeps/333" target="_blank" rel="noopener">JEP 333: ZGC: A Scalable Low-Latency Garbage Collector</a><br><a href="https://wiki.openjdk.java.net/display/zgc/Main" target="_blank" rel="noopener">OpenJDK Wiki About ZGC</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK 11即将于09/25正式发布，包含了诸多新的特性，主要的新特性JEP(JDK Enhancement Proposal 特性增强提议)有17个，参见下表&lt;/p&gt;&lt;ul&gt;&lt;li&gt;181: Nest-Based Access Control&lt;/li&gt;&lt;li&gt;309: Dynamic Class-File Constants&lt;/li&gt;&lt;li&gt;315: Improve Aarch64 Intrinsics&lt;/li&gt;&lt;li&gt;318: Epsilon: A No-Op Garbage Collector&lt;/li&gt;&lt;li&gt;320: Remove the Java EE and CORBA Modules&lt;/li&gt;&lt;li&gt;321: HTTP Client (Standard)&lt;/li&gt;&lt;li&gt;323: Local-Variable Syntax for Lambda Parameters&lt;/li&gt;&lt;li&gt;324: Key Agreement with Curve25519 and Curve448&lt;/li&gt;&lt;li&gt;327: Unicode 10&lt;/li&gt;&lt;li&gt;328: Flight Recorder&lt;/li&gt;&lt;li&gt;329: ChaCha20 and Poly1305 Cryptographic Algorithms&lt;/li&gt;&lt;li&gt;330: Launch Single-File Source-Code Programs&lt;/li&gt;&lt;li&gt;331: Low-Overhead Heap Profiling&lt;/li&gt;&lt;li&gt;332: Transport Layer Security (TLS) 1.3&lt;/li&gt;&lt;li&gt;333: ZGC: A Scalable Low-Latency Garbage Collector(Experimental)&lt;/li&gt;&lt;li&gt;335: Deprecate the Nashorn JavaScript Engine&lt;/li&gt;&lt;li&gt;336: Deprecate the Pack200 Tools and API&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中，非常值得大家关注的是JEP-333，ZGC，一个可扩展的低延迟垃圾回收器。ZGC目前仍处于实验阶段，不建议在生产环境使用。&lt;br&gt;目前使用ZGC需要添加JVM参数：-XX:+UnlockExperimentalVMOptions -XX:+UseZGC&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>推荐计算机科学书籍</title>
    <link href="https://leicode.com/posts/ba7b25c0/"/>
    <id>https://leicode.com/posts/ba7b25c0/</id>
    <published>2018-08-30T06:01:49.000Z</published>
    <updated>2018-09-07T07:18:29.699Z</updated>
    
    <content type="html"><![CDATA[<p>值得一读的高分计算机书籍：<br><a href="https://www.douban.com/doulist/37472347/?start=0&amp;sort=seq&amp;playable=0&amp;sub_type=" target="_blank" rel="noopener">https://www.douban.com/doulist/37472347/?start=0&amp;sort=seq&amp;playable=0&amp;sub_type=</a></p><p>从我的角度来看呢，高级程序员推荐必读</p><h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><p><a href="https://book.douban.com/subject/5407246/" target="_blank" rel="noopener">深入理解计算机系统（英文版·第2版）</a></p><h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><p><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">HTTP权威指南</a></p><p><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">图解HTTP</a></p><p><a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">TCP/IP详解 卷1：协议</a></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">现代操作系统（原书第4版）</a></p><p><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/#book-chapters" target="_blank" rel="noopener">Operating Systems</a> 在线免费版本</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener">高性能MySQL</a></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法（第4版）</a></p><p><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">算法导论（原书第3版）</a></p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;值得一读的高分计算机书籍：&lt;br&gt;&lt;a href=&quot;https://www.douban.com/doulist/37472347/?start=0&amp;amp;sort=seq&amp;amp;playable=0&amp;amp;sub_type=&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch-nested-query</title>
    <link href="https://leicode.com/posts/3f81b35b/"/>
    <id>https://leicode.com/posts/3f81b35b/</id>
    <published>2018-08-27T05:23:35.000Z</published>
    <updated>2018-09-07T07:18:29.697Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch嵌套查询，具体可参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-nested-query.html" target="_blank" rel="noopener">Nested Query</a>.</p><p>建议还是要多看多熟悉Elasticsearch的官方文档，比到处去搜强多了。</p><p>简而言之，在对ES doc的多层嵌套对象进行查询的时候，要使用Nested Query，常规查询无效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;nested&quot; : &#123;</span><br><span class="line">            &quot;path&quot; : &quot;obj&quot;,</span><br><span class="line">            &quot;query&quot; : &#123;</span><br><span class="line">                &quot;bool&quot; : &#123;</span><br><span class="line">                    &quot;must&quot; : [</span><br><span class="line">                        &#123; &quot;match&quot; : &#123;&quot;obj.info.name&quot; : &quot;zhangsan&quot;&#125; &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Elasticsearch嵌套查询，具体可参考&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-nested-query.html&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="elasticsearch" scheme="https://leicode.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>RBAC简要设计</title>
    <link href="https://leicode.com/posts/5969db7a/"/>
    <id>https://leicode.com/posts/5969db7a/</id>
    <published>2018-06-07T05:49:24.000Z</published>
    <updated>2018-09-07T07:18:29.698Z</updated>
    
    <content type="html"><![CDATA[<p>Role-Based-Access-Control System Design.<br>比较常见的基于角色的访问控制系统，这次是主要了解和简单设计，不涉及到特别复杂的功能。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>参考文档：<a href="https://blog.csdn.net/yangwenxue_admin/article/details/73936803" target="_blank" rel="noopener">https://blog.csdn.net/yangwenxue_admin/article/details/73936803</a></p><p>RBAC（Role-Based Access Control，基于角色的访问控制），就是用户<strong>通过角色与权限进行关联</strong>。</p><p>其主要特点如下：</p><p>一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。<br>这种模型中，用户与角色之间，角色与权限之间，一般是多对多的关系。<br>在此基础上，可以扩展出用户组等实体类型。<br>根据实际需求，可以考虑增加用户组，并对具体权限的类型进行了细分。<br><a id="more"></a></p><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><p>角色是什么？可以理解为一定数量的权限的集合，权限的载体。例如：一个论坛系统，“超级管理员”、“版主”都是角色。版主可管理版内的帖子、可管理版内的用户等，这些是权限。要给某个用户授予这些权限，不需要直接将权限授予用户，可将“版主”这个角色赋予该用户。</p><h1 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h1><p>当用户的数量非常大时，要给系统每个用户逐一授权（授角色），是件非常烦琐的事情。这时，就需要给用户分组，每个用户组内有多个用户。</p><p>除了可给用户授权外，还可以给用户组授权。这样一来，用户拥有的所有权限，就是用户个人拥有的权限与该用户所在用户组拥有的权限之和。</p><h1 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h1><p>权限细分出“权限类型”，我们根据它的取值来区分是哪一类权限，进而与特定的表进行关联。如“MENU”表示菜单的访问权限、“RESOURCE”表示可供访问的URL、“FILE”表示文件的修改权限等。</p><p>这样设计的好处有二：</p><ul><li>不需要区分哪些是权限操作，哪些是资源，（实际上，有时候也不好区分，如菜单，把它理解为资源呢还是功能模块权限呢？）。</li><li>方便扩展，当系统要对新的内容或实体进行权限控制时，我只需要建立一个新的关联表“权限XX关联表”，并确定这类权限的权限类型字符串。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Role-Based-Access-Control System Design.&lt;br&gt;比较常见的基于角色的访问控制系统，这次是主要了解和简单设计，不涉及到特别复杂的功能。&lt;/p&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;参考文档：&lt;a href=&quot;https://blog.csdn.net/yangwenxue_admin/article/details/73936803&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/yangwenxue_admin/article/details/73936803&lt;/a&gt;&lt;/p&gt;&lt;p&gt;RBAC（Role-Based Access Control，基于角色的访问控制），就是用户&lt;strong&gt;通过角色与权限进行关联&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;其主要特点如下：&lt;/p&gt;&lt;p&gt;一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。&lt;br&gt;这种模型中，用户与角色之间，角色与权限之间，一般是多对多的关系。&lt;br&gt;在此基础上，可以扩展出用户组等实体类型。&lt;br&gt;根据实际需求，可以考虑增加用户组，并对具体权限的类型进行了细分。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MAC &amp; HMAC</title>
    <link href="https://leicode.com/posts/19e9c6b0/"/>
    <id>https://leicode.com/posts/19e9c6b0/</id>
    <published>2018-05-05T05:27:51.000Z</published>
    <updated>2018-09-30T06:23:35.999Z</updated>
    
    <content type="html"><![CDATA[<p>在前一段做安全接入的时候，结合了多种安全和密码学的算法，设计了一套敏感数据传输方案。今天主要介绍的是其中用到的消息认证码（Message authentication code，缩写为MAC）。这里的MAC并不是网卡物理地址的那个MAC，注意区分。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在密码学中，MAC是一小段字节信息，用于验证发送消息的完整性(data integrity)，以及消息的身份认证(确定消息的发送者的身份 - its authenticity)。<br>另一方面来说，MAC可以做到识别内容篡改和内容伪造。<br>回忆一下，Hash算法例如SHA256、MD5等，也可以完成消息完整性的验证，数字签名算法(其实内部也结合了消息散列函数)也可以达到MAC的这两项作用。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>MAC（生成tag）由三个算法组成：</p><ul><li>密钥key生成算法。从密钥空间中选择出来的key是均匀和随机的。</li><li>签名算法。给定Key和消息，生成唯一的tag。</li><li>验证算法。给定Key，tag和消息，验证是否符合。</li></ul><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>MAC方法必须能够抵御chosen-plaintext attacks。<br>简单解释一下：<br>Alice和Bob约定一个只有他们两个知道的MAC key。Eve在监视他们的通信，并且可以获取到他们通信的信息和对应的tags。<br>但是Eve根据得到的这些对应信息，并不能推算出其他消息的有效tag。<br>即使Eve可以说服Alice和Bob发送一些指定的信息，也依旧不能推算出来。<br>在Eve看来，tag是完全随机的字节。<br><a id="more"></a></p><p>MAC与数字签名的主要不同点，在于MAC在生成和验证阶段使用的是相同的key，接收者和发送者必须实现约定相同的key，才能使用MAC方法进行通信。<br>数字签名则是使用的非对称的公钥和私钥机制，使用私钥进行签名，公钥验证签名。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>HMAC是MAC方法的一种具体实现，使用key和一些特点的Hash函数来生成MAC，常见的有Hmac_MD5，Hmac_SHA1，Hmac_SHA256，Hmac_SHA384，Hmac_SHA512.</p><p>Java代码示例<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private static final String HMAC_ALGORITHM = &quot;HmacSHA256&quot;;</span><br><span class="line">private static final int HMAC_KEY_LENGTH_BITS = 256;</span><br><span class="line"></span><br><span class="line">public static SecretKey getSecretKey() throws Exception &#123;</span><br><span class="line">    KeyGenerator keyGenerator = KeyGenerator.getInstance(HMAC_ALGORITHM);</span><br><span class="line">    return keyGenerator.generateKey();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static byte[] randomBytes(int length) &#123;</span><br><span class="line">    SecureRandom random = new SecureRandom();</span><br><span class="line">    byte[] b = new byte[length];</span><br><span class="line">    random.nextBytes(b);</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Generate the mac based on HMAC_ALGORITHM</span><br><span class="line"> *</span><br><span class="line"> * @param integrityKey   The key used for hmac</span><br><span class="line"> * @param byteCipherText the cipher text</span><br><span class="line"> *</span><br><span class="line"> * @return A byte array of the HMAC for the given key and ciphertext</span><br><span class="line"> *</span><br><span class="line"> * @throws NoSuchAlgorithmException</span><br><span class="line"> * @throws InvalidKeyException</span><br><span class="line"> */</span><br><span class="line">public static byte[] generateMac(byte[] byteCipherText, SecretKey integrityKey)</span><br><span class="line">        throws NoSuchAlgorithmException, InvalidKeyException &#123;</span><br><span class="line">    // Now compute the mac for later integrity checking</span><br><span class="line">    Mac sha256HMAC = Mac.getInstance(HMAC_ALGORITHM);</span><br><span class="line">    sha256HMAC.init(integrityKey);</span><br><span class="line">    return sha256HMAC.doFinal(byteCipherText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>参考：<br><a href="https://en.wikipedia.org/wiki/Message_authentication_code" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Message_authentication_code</a><br><a href="https://en.wikipedia.org/wiki/Chosen-plaintext_attack" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Chosen-plaintext_attack</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前一段做安全接入的时候，结合了多种安全和密码学的算法，设计了一套敏感数据传输方案。今天主要介绍的是其中用到的消息认证码（Message authentication code，缩写为MAC）。这里的MAC并不是网卡物理地址的那个MAC，注意区分。&lt;/p&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;在密码学中，MAC是一小段字节信息，用于验证发送消息的完整性(data integrity)，以及消息的身份认证(确定消息的发送者的身份 - its authenticity)。&lt;br&gt;另一方面来说，MAC可以做到识别内容篡改和内容伪造。&lt;br&gt;回忆一下，Hash算法例如SHA256、MD5等，也可以完成消息完整性的验证，数字签名算法(其实内部也结合了消息散列函数)也可以达到MAC的这两项作用。&lt;/p&gt;&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;MAC（生成tag）由三个算法组成：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;密钥key生成算法。从密钥空间中选择出来的key是均匀和随机的。&lt;/li&gt;&lt;li&gt;签名算法。给定Key和消息，生成唯一的tag。&lt;/li&gt;&lt;li&gt;验证算法。给定Key，tag和消息，验证是否符合。&lt;/li&gt;&lt;/ul&gt;&lt;h1 id=&quot;安全&quot;&gt;&lt;a href=&quot;#安全&quot; class=&quot;headerlink&quot; title=&quot;安全&quot;&gt;&lt;/a&gt;安全&lt;/h1&gt;&lt;p&gt;MAC方法必须能够抵御chosen-plaintext attacks。&lt;br&gt;简单解释一下：&lt;br&gt;Alice和Bob约定一个只有他们两个知道的MAC key。Eve在监视他们的通信，并且可以获取到他们通信的信息和对应的tags。&lt;br&gt;但是Eve根据得到的这些对应信息，并不能推算出其他消息的有效tag。&lt;br&gt;即使Eve可以说服Alice和Bob发送一些指定的信息，也依旧不能推算出来。&lt;br&gt;在Eve看来，tag是完全随机的字节。&lt;br&gt;
    
    </summary>
    
      <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="develop" scheme="https://leicode.com/tags/develop/"/>
    
      <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Redis常用开发应用规范</title>
    <link href="https://leicode.com/posts/1113160e/"/>
    <id>https://leicode.com/posts/1113160e/</id>
    <published>2018-04-16T06:32:37.000Z</published>
    <updated>2018-09-10T07:19:03.557Z</updated>
    
    <content type="html"><![CDATA[<p>Redis在日常开发中可以说是非常常用的服务了，提供了灵活的数据结构、高效率、方便的lua script等多种功能。<br>在开发运用过程中，有一些点是需要特别注意的，也是对Redis的一种比较正确的使用方式，简单总结如下：</p><ol><li>KEY的格式要规范，可读性要强，注意控制KEY的长度。</li><li>VALUE的大小限制。Redis限制每个String类型value大小不超过512MB，<br>实际开发中，不要超过10KB，否则会对CPU和网卡造成极大负载。<br>hash、list、set、zset元素个数不要超过5000。<a id="more"></a></li><li>选择合适的数据类型，而不是一味的用string类型。建议多用hash，有压缩算法，可以降低开销。<blockquote><blockquote><p>hash类型特别适合用于存储对象。在field的数量在限制的范围内以及value的长度小于指定的字节数，那么此时的hash类型是用zipmap存储的，所以会比较节省内存。可以在配置文件里面修改配置项来控制field的数量和value的字节数大小。<br>hash-max-zipmap-entries 512 #配置字段最多512个<br>hash-max-zipmap-value 64 #配置value最大为64字节。<br>必须满足以上两个条件，那么该key会被压缩。否则就是按照正常的hash结构来存储hash类型的key。</p></blockquote></blockquote></li><li>设置过期时间，减少内存占用。</li><li>禁用KEYS命令。查找效率是O(N)，很可能阻塞正常请求，而且CPU负载过大。</li><li>禁用flushall，flushdb命令，过于危险。</li><li>建议使用批量操作提供效率<blockquote><blockquote><p>原生命令：例如mget、mset。<br>非原生命令：可以使用pipeline提高效率。</p></blockquote></blockquote></li></ol><p>参考文档：<br><a href="https://blog.csdn.net/glx490676405/article/details/79580748" target="_blank" rel="noopener">阿里云Redis开发规范</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis在日常开发中可以说是非常常用的服务了，提供了灵活的数据结构、高效率、方便的lua script等多种功能。&lt;br&gt;在开发运用过程中，有一些点是需要特别注意的，也是对Redis的一种比较正确的使用方式，简单总结如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;KEY的格式要规范，可读性要强，注意控制KEY的长度。&lt;/li&gt;&lt;li&gt;VALUE的大小限制。Redis限制每个String类型value大小不超过512MB，&lt;br&gt;实际开发中，不要超过10KB，否则会对CPU和网卡造成极大负载。&lt;br&gt;hash、list、set、zset元素个数不要超过5000。
    
    </summary>
    
      <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="NoSQL" scheme="https://leicode.com/tags/NoSQL/"/>
    
      <category term="Redis" scheme="https://leicode.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>基于Redis实现的Rate limiter (限流器)</title>
    <link href="https://leicode.com/posts/9e983597/"/>
    <id>https://leicode.com/posts/9e983597/</id>
    <published>2018-04-10T09:46:12.000Z</published>
    <updated>2018-09-07T07:18:29.695Z</updated>
    
    <content type="html"><![CDATA[<p>首先建议大家好好阅读一下官方文章，如何利用incr命令实现一些应用模式（Pattern）。<br><a href="https://redis.io/commands/incr" target="_blank" rel="noopener">INCR命令的介绍与应用</a></p><p>本文不对原文进行大段翻译，主要讲下自己的理解。</p><h1 id="模式：计数器"><a href="#模式：计数器" class="headerlink" title="模式：计数器"></a>模式：计数器</h1><p>Redis原子性自增操作，最明显的应用就是计数器了，类似Java的AtomicInteger。<br>可以结合EXPIRE，INCRBY，GET，SET，DECR等操作做很多很多事情。<br>多命令的情况下要注意事务或者使用Lua script哦。</p><h1 id="模式：Rate-limiter-限流器"><a href="#模式：Rate-limiter-限流器" class="headerlink" title="模式：Rate limiter 限流器"></a>模式：Rate limiter 限流器</h1><h2 id="限流器的应用"><a href="#限流器的应用" class="headerlink" title="限流器的应用"></a>限流器的应用</h2><p>限流器的应用非常广泛，比如Github对外提供了非常丰富的API，但考虑到数据安全和系统资源，对匿名用户和经过认证的用户的请求API频率都是要有限制的。<br>可以看看Github API的<a href="https://developer.github.com/v3/#rate-limiting" target="_blank" rel="noopener">Rate limiting</a>。<br>认证的用户每小时请求次数是5000，没认证的用户每小时只能请求60次，依靠原始IP来区分未认证用户。</p><p>上面介绍了一个很典型的应用场景，如果一个系统对我提供服务，开放API的话，为了防刷和系统资源的平衡，限流器的应用是很有必要的。<br>调用Github API返回结果的时候，response的Header里面都会带有限流的信息，这是一个非常好的设计，大致如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -i https://api.github.com/users/octocat</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Jul 2013 17:27:06 GMT</span><br><span class="line">Status: 200 OK</span><br><span class="line">X-RateLimit-Limit: 60</span><br><span class="line">X-RateLimit-Remaining: 56</span><br><span class="line">X-RateLimit-Reset: 1372700873</span><br></pre></td></tr></table></figure><p></p><p>我在做网关设计中也借鉴过这种设计方式，另外也参考过spring-cloud-zuul微服务网关中的一个<a href="https://github.com/marcosbarbero/spring-cloud-zuul-ratelimit" target="_blank" rel="noopener">API限流库</a>的代码，里面Filter的设计还是很不错的。</p><a id="more"></a><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>针对每个来访IP，限制每秒只能访问10次。</p><h2 id="模式1：最直接的实现"><a href="#模式1：最直接的实现" class="headerlink" title="模式1：最直接的实现"></a>模式1：最直接的实现</h2><p>KEY值的设计会决定你的解决方案。<br>一种是KEY是IP+当前秒数（UNIX时间戳），那么在该秒内的所有访问，都会对这个KEY执行INCR命令，这个KEY在当前秒之后就没用了其实，设置过期时间大于1秒即可。<br>该方案的伪码表示如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION LIMIT_API_CALL(ip)</span><br><span class="line">ts = CURRENT_UNIX_TIME()</span><br><span class="line">keyname = ip+&quot;:&quot;+ts</span><br><span class="line">current = GET(keyname)</span><br><span class="line">IF current != NULL AND current &gt; 10 THEN</span><br><span class="line">    ERROR &quot;too many requests per second&quot;</span><br><span class="line">ELSE</span><br><span class="line">    MULTI</span><br><span class="line">        INCR(keyname,1)</span><br><span class="line">        EXPIRE(keyname,10)</span><br><span class="line">    EXEC</span><br><span class="line">    PERFORM_API_CALL()</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p></p><p>显而易见的，该方案的缺点是系统访问量大时，比如当前秒有10000个IP来访问，Redis中就会出现10000个KEY，虽然有Redis的过期删除，10秒过期就会导致10秒<br>内的所有IP访问的KEY堆积，大量占用Redis的内存。</p><h2 id="模式2：IP为KEY"><a href="#模式2：IP为KEY" class="headerlink" title="模式2：IP为KEY"></a>模式2：IP为KEY</h2><p>这种设计也很直接啊，IP为KEY，过期时间1秒，有IP访问就自增，超过1秒，该KEY就会过期，后面的访问重新生成KEY。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION LIMIT_API_CALL(ip):</span><br><span class="line">current = GET(ip)</span><br><span class="line">IF current != NULL AND current &gt; 10 THEN</span><br><span class="line">    ERROR &quot;too many requests per second&quot;</span><br><span class="line">ELSE</span><br><span class="line">    value = INCR(ip)</span><br><span class="line">    IF value == 1 THEN</span><br><span class="line">        EXPIRE(ip,1)</span><br><span class="line">    END</span><br><span class="line">    PERFORM_API_CALL()</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p></p><p>官网很明确的指出了这里面的竞争条件，假如多个线程访问，都进入了ELSE进行了自增，ip的值就变为2或更大，EXPIRE没有执行，这个KEY就泄露了，永远保存在Redis中，<br>只有后面又遇到相同IP地址的访问。<br>因为有IF判断语句，所以这里不能使用MULTI-EXEC事务，必须使用lua脚本，提升了设计复杂度。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local current</span><br><span class="line">current = redis.call(&quot;incr&quot;,KEYS[1])</span><br><span class="line">if tonumber(current) == 1 then</span><br><span class="line">    redis.call(&quot;expire&quot;,KEYS[1],1)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p></p><h2 id="模式3：新思路使用list"><a href="#模式3：新思路使用list" class="headerlink" title="模式3：新思路使用list"></a>模式3：新思路使用list</h2><p>直接上lua script好了。KEYS[1]就是访问IP，ARGV[2]是超时时间的ms值，这里是1000，ARGV[1]比较随意，可以是访问时间的ms。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (redis.call(&apos;exists&apos;, KEYS[1]) == 0) then </span><br><span class="line">    redis.call(&apos;rpush&apos;, KEYS[1], ARGV[1]);</span><br><span class="line">    return redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[2]); </span><br><span class="line">else</span><br><span class="line">    return redis.call(&apos;rpushx&apos;, KEYS[1], ARGV[1]); </span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p></p><p>先执行LLEN(KEY)，如果超过限制则返回，否则执行LUA脚本。</p><p>之前有个小同事在这里用了KEYS IP*的方式，类似模式1，这里大家要注意，在很多Redis的线上系统中是会禁用KEYS的，因为KEYS会造成系统CPU的使用率骤增，<br>会导致系统不稳定。我直接改成了这个lua script的用法，现在运行的也很不错。</p><p>这个LUA脚本解决了官网说的竞争问题，官网的伪代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION LIMIT_API_CALL(ip)</span><br><span class="line">current = LLEN(ip)</span><br><span class="line">IF current &gt; 10 THEN</span><br><span class="line">    ERROR &quot;too many requests per second&quot;</span><br><span class="line">ELSE</span><br><span class="line">    IF EXISTS(ip) == FALSE</span><br><span class="line">        MULTI</span><br><span class="line">            RPUSH(ip,ip)</span><br><span class="line">            EXPIRE(ip,1)</span><br><span class="line">        EXEC</span><br><span class="line">    ELSE</span><br><span class="line">        RPUSHX(ip,ip)</span><br><span class="line">    END</span><br><span class="line">    PERFORM_API_CALL()</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p></p><p>简单解释下，这里的竞争在IF EXISTS，多个线程同时判断了IF，都进入了IF，准备执行MULTI-EXEC，<br>当然这里只能顺序执行，一个线程执行完之后，另一个线程也执行，EXPIRE以最后执行的线程为准，由于过期时间的改变，会有略微不准确的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先建议大家好好阅读一下官方文章，如何利用incr命令实现一些应用模式（Pattern）。&lt;br&gt;&lt;a href=&quot;https://redis.io/commands/incr&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;INCR命令的介绍与应用&lt;/a&gt;&lt;/p&gt;&lt;p&gt;本文不对原文进行大段翻译，主要讲下自己的理解。&lt;/p&gt;&lt;h1 id=&quot;模式：计数器&quot;&gt;&lt;a href=&quot;#模式：计数器&quot; class=&quot;headerlink&quot; title=&quot;模式：计数器&quot;&gt;&lt;/a&gt;模式：计数器&lt;/h1&gt;&lt;p&gt;Redis原子性自增操作，最明显的应用就是计数器了，类似Java的AtomicInteger。&lt;br&gt;可以结合EXPIRE，INCRBY，GET，SET，DECR等操作做很多很多事情。&lt;br&gt;多命令的情况下要注意事务或者使用Lua script哦。&lt;/p&gt;&lt;h1 id=&quot;模式：Rate-limiter-限流器&quot;&gt;&lt;a href=&quot;#模式：Rate-limiter-限流器&quot; class=&quot;headerlink&quot; title=&quot;模式：Rate limiter 限流器&quot;&gt;&lt;/a&gt;模式：Rate limiter 限流器&lt;/h1&gt;&lt;h2 id=&quot;限流器的应用&quot;&gt;&lt;a href=&quot;#限流器的应用&quot; class=&quot;headerlink&quot; title=&quot;限流器的应用&quot;&gt;&lt;/a&gt;限流器的应用&lt;/h2&gt;&lt;p&gt;限流器的应用非常广泛，比如Github对外提供了非常丰富的API，但考虑到数据安全和系统资源，对匿名用户和经过认证的用户的请求API频率都是要有限制的。&lt;br&gt;可以看看Github API的&lt;a href=&quot;https://developer.github.com/v3/#rate-limiting&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rate limiting&lt;/a&gt;。&lt;br&gt;认证的用户每小时请求次数是5000，没认证的用户每小时只能请求60次，依靠原始IP来区分未认证用户。&lt;/p&gt;&lt;p&gt;上面介绍了一个很典型的应用场景，如果一个系统对我提供服务，开放API的话，为了防刷和系统资源的平衡，限流器的应用是很有必要的。&lt;br&gt;调用Github API返回结果的时候，response的Header里面都会带有限流的信息，这是一个非常好的设计，大致如下：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl -i https://api.github.com/users/octocat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HTTP/1.1 200 OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date: Mon, 01 Jul 2013 17:27:06 GMT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Status: 200 OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X-RateLimit-Limit: 60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X-RateLimit-Remaining: 56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X-RateLimit-Reset: 1372700873&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我在做网关设计中也借鉴过这种设计方式，另外也参考过spring-cloud-zuul微服务网关中的一个&lt;a href=&quot;https://github.com/marcosbarbero/spring-cloud-zuul-ratelimit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;API限流库&lt;/a&gt;的代码，里面Filter的设计还是很不错的。&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="NoSQL" scheme="https://leicode.com/tags/NoSQL/"/>
    
      <category term="Redis" scheme="https://leicode.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统下的唯一ID生成问题</title>
    <link href="https://leicode.com/posts/8a9934c8/"/>
    <id>https://leicode.com/posts/8a9934c8/</id>
    <published>2018-03-06T05:57:14.000Z</published>
    <updated>2018-09-07T07:18:29.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>在一个应用中会产生大量的业务数据，这些数据往往需要一个ID来标记，在关系型数据库中，主键往往就是这个作用。<br>在大多数数据库中，自增的64bit long类型主键，就是用来解决这个问题的。有时，我们必须在应用层控制ID的生成，<br>这时我们就要缓存下最近生成的ID是多少，以此来跟踪生成的序列。</p><p>如果数据库中的数据做了分片（shard，分库分表），那么在一个表中自增的64bit long主键显然不能适用，多个节点下<br>必然会发生碰撞问题。与此类似，当应用分布在多个节点运行的时候，简单在内存缓存最近的一个ID，也同样不能满足需要。<br><a id="more"></a></p><h1 id="分布式环境下的解决方案"><a href="#分布式环境下的解决方案" class="headerlink" title="分布式环境下的解决方案"></a>分布式环境下的解决方案</h1><h2 id="中心式"><a href="#中心式" class="headerlink" title="中心式"></a>中心式</h2><h3 id="数据库的中心化自增"><a href="#数据库的中心化自增" class="headerlink" title="数据库的中心化自增"></a>数据库的中心化自增</h3><p><a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Flickr的Ticket Server方案</a><br>MySQL的自增显然不能在多库多表的情况下使用，那使用单库单表呢？</p><p>活用MySQL的REPLACE INTO。</p><blockquote><p>REPLACE works exactly like INSERT, except that if an old row in the table has the same value as a new row for a PRIMARY KEY or a UNIQUE index, the old row is deleted before the new row is inserted.</p></blockquote><p>新建两张表，Tickets32 for 32-bit IDs, and Tickets64 for 64-bit IDs.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `Tickets64` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL auto_increment,</span><br><span class="line">  `stub` char(1) NOT NULL default &apos;&apos;,</span><br><span class="line">  PRIMARY KEY  (`id`),</span><br><span class="line">  UNIQUE KEY `stub` (`stub`)</span><br><span class="line">) ENGINE=MyISAM</span><br></pre></td></tr></table></figure><p>当需要一个新的64bit唯一ID时，执行以下SQL：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO Tickets64 (stub) VALUES (&apos;a&apos;);</span><br><span class="line">SELECT LAST_INSERT_ID();</span><br></pre></td></tr></table></figure><p></p><p>因为是单库，怎么解决单点故障问题呢？把ID的数值分成奇数和偶数，在两台数据库服务器上部署。<br>配置如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TicketServer1:</span><br><span class="line">auto-increment-increment = 2</span><br><span class="line">auto-increment-offset = 1</span><br><span class="line"></span><br><span class="line">TicketServer2:</span><br><span class="line">auto-increment-increment = 2</span><br><span class="line">auto-increment-offset = 2</span><br></pre></td></tr></table></figure><p></p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>若系统中已经依赖了Redis，使用Redis也是很好的选择，加上现在Redis已经有了集群化的高可用方案。<br>Redis的INCR命令，可以直接获取增加后的值。如果需要定制更复杂点的生成算法，使用lua脚本结合多个命令即可，lua脚本可以保证原子性。<br>缺点就是依赖Redis啦，每次获取都有一次远程调用，如果很担忧效率的话，可以一次获取批量的ID。</p><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>zookeeper主要通过其znode数据版本来生成序列号，可以生成32位和64位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号。<br>很少会使用zookeeper来生成唯一ID。性能方面会不太理想，但也算一种思路。</p><h3 id="其他的分布式集群协调器"><a href="#其他的分布式集群协调器" class="headerlink" title="其他的分布式集群协调器"></a>其他的分布式集群协调器</h3><p>在不使用数据库的情况下，通过一个后台服务对外提供高可用的、固定步长标识生成，则需要分布式的集群协调器进行。</p><p>一般的，主流协调器有两类：</p><ul><li>以强一致性为目标的：ZooKeeper为代表</li><li>以最终一致性为目标的：Consul为代表</li></ul><p>ZooKeeper的强一致性，是由Paxos协议保证的；Consul的最终一致性，是由Gossip协议保证的。</p><p>在步长累计型生成算法中，最核心的就是保持一个累计值在整个集群中的「强一致性」。同时，这也会为唯一性标识的生成带来新的形成瓶颈。</p><p>参考：<a href="https://juejin.im/entry/57fe1be1bf22ec0064ad96ce" target="_blank" rel="noopener">https://juejin.im/entry/57fe1be1bf22ec0064ad96ce</a></p><h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>Universally unique identifier (UUID)，有时也被称为globally unique identifier(GUID)。<br>拥有RFC标准，应用非常广泛。</p><p>在微软的相关类库中，直接找GUID就可以了。<br>在Java语言中，可以直接使用java.util.UUID类的randomUUID()静态方法，直接可以得到一个类型4的UUID，<br>这也是最常用最简单的生成方法。</p><p>那么什么是类型4呢，是基于伪随机生成UUID的一种方法类型，具体可以学习下UUID的<a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" target="_blank" rel="noopener">Wiki</a>。</p><p>标准UUID的优势：</p><ul><li>各大编程语言自带实现，编码简单，直接使用。没有其他依赖限制。</li><li>性能好。</li><li>全球唯一，碰撞率极小。</li></ul><p>缺点：</p><ul><li>没有顺序性。</li><li>字符串存储，一般需要36个字符表示，比较占用存储空间。</li><li>随机生成，可读性较低。</li><li>用作数据库主键或作为索引的话，查询效率会比较低。<a href="https://medium.com/@varuntayal/re-design-primary-keys-and-ids-9b9776d442b" target="_blank" rel="noopener">UUID与自增64bit long ID的数据库效率比较</a></li></ul><p>建议仔细阅读以下文档：<br><a href="http://www.ietf.org/rfc/rfc4122.txt" target="_blank" rel="noopener">RFC4122</a><br><a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" target="_blank" rel="noopener">UUID Wiki</a></p><h2 id="Snowflake算法"><a href="#Snowflake算法" class="headerlink" title="Snowflake算法"></a>Snowflake算法</h2><p>Twitter贡献的开源分布式ID生成算法，可以生成一个64bit long型ID。<br><img src="https://i.loli.net/2018/09/06/5b90cb6499eff.png" alt="1081851-20161216164125479-1591675346.png"><br>由于该算法依赖于Twitter的一系列基础设施，已经不再维护了。如果要使用的话，可能需要进行一些改造。</p><p><a href="https://github.com/twitter/snowflake" target="_blank" rel="noopener">Source code</a><br><a href="https://segmentfault.com/a/1190000011282426" target="_blank" rel="noopener">看完这一篇就深入理解了</a></p><p><a href="http://darktea.github.io/notes/2013/12/08/Unique-ID" target="_blank" rel="noopener">其他一些变种的flake算法</a></p><h2 id="MongoDB的ObjectId"><a href="#MongoDB的ObjectId" class="headerlink" title="MongoDB的ObjectId"></a>MongoDB的ObjectId</h2><p>和Snowflake算法类似。它设计成轻量型的，不同的机器都能用全局唯一的同种方法方便地生成。<br>MongoDB从一开始就设计用来作为分布式数据库，处理多个节点是一个核心要求，在分布式环境中也很容易应用。</p><p>其他参考文章：<br><a href="https://medium.com/@varuntayal/what-does-it-take-to-generate-cluster-wide-unique-ids-in-a-distributed-system-d505b9eaa46e" target="_blank" rel="noopener">What does it take to generate cluster wide unique ID’s in a distributed system</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h1&gt;&lt;p&gt;在一个应用中会产生大量的业务数据，这些数据往往需要一个ID来标记，在关系型数据库中，主键往往就是这个作用。&lt;br&gt;在大多数数据库中，自增的64bit long类型主键，就是用来解决这个问题的。有时，我们必须在应用层控制ID的生成，&lt;br&gt;这时我们就要缓存下最近生成的ID是多少，以此来跟踪生成的序列。&lt;/p&gt;&lt;p&gt;如果数据库中的数据做了分片（shard，分库分表），那么在一个表中自增的64bit long主键显然不能适用，多个节点下&lt;br&gt;必然会发生碰撞问题。与此类似，当应用分布在多个节点运行的时候，简单在内存缓存最近的一个ID，也同样不能满足需要。&lt;br&gt;
    
    </summary>
    
      <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="develop" scheme="https://leicode.com/tags/develop/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB-ObjectId</title>
    <link href="https://leicode.com/posts/397fc4ba/"/>
    <id>https://leicode.com/posts/397fc4ba/</id>
    <published>2018-03-04T06:15:35.000Z</published>
    <updated>2018-09-07T07:18:29.692Z</updated>
    
    <content type="html"><![CDATA[<p>对于分布式唯一ID的生成，有几种比较好的思路，划分命名空间并行生成，是现在比较流行的一种方式，例如Twitter提出的非常有名的<br>Snowflake算法。与之类似的是，在很早之前，MongoDB的ObjectId生成算法就是类似的这种思路，在MongoDB的0.9.10(2009年8月24日发布)版本中就已经采用。</p><p>在最新的MongoDB-Java-Driver文档中，可以看到ObjectId的相关API说明。参考资料如下：<br><a href="http://mongodb.github.io/mongo-java-driver/3.8/javadoc/org/bson/types/ObjectId.html" target="_blank" rel="noopener">Class ObjectId</a><br><a href="https://github.com/mongodb/mongo-java-driver/blob/master/bson/src/main/org/bson/types/ObjectId.java" target="_blank" rel="noopener">Source code - ObjectId.java</a><br><a id="more"></a></p><p>具体来说，12字节的MongoDB ObjectId的结构是</p><ul><li>a 4-byte value representing the seconds since the Unix epoch</li><li>a 3-byte machine identifier</li><li>a 2-byte process id</li><li>a 3-byte counter, starting with a random value</li></ul><p>可以看出，最小的划分粒度是 秒*进程实例，<br>对于单个进程来说，每秒的ID容量是最后一个字段的3个字节，24bit，即大约16777216个ID，这个容量已经可以满足大部分情况下的ID生成需求了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于分布式唯一ID的生成，有几种比较好的思路，划分命名空间并行生成，是现在比较流行的一种方式，例如Twitter提出的非常有名的&lt;br&gt;Snowflake算法。与之类似的是，在很早之前，MongoDB的ObjectId生成算法就是类似的这种思路，在MongoDB的0.9.10(2009年8月24日发布)版本中就已经采用。&lt;/p&gt;&lt;p&gt;在最新的MongoDB-Java-Driver文档中，可以看到ObjectId的相关API说明。参考资料如下：&lt;br&gt;&lt;a href=&quot;http://mongodb.github.io/mongo-java-driver/3.8/javadoc/org/bson/types/ObjectId.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Class ObjectId&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/mongodb/mongo-java-driver/blob/master/bson/src/main/org/bson/types/ObjectId.java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Source code - ObjectId.java&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://leicode.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="MongoDB" scheme="https://leicode.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Jackson转换Json的严格字母序</title>
    <link href="https://leicode.com/posts/4147250/"/>
    <id>https://leicode.com/posts/4147250/</id>
    <published>2018-02-08T07:22:48.000Z</published>
    <updated>2018-09-12T07:03:59.538Z</updated>
    
    <content type="html"><![CDATA[<p>经常使用Jackson的同学肯定知道这个注解，<br>@JsonPropertyOrder(alphabetic = true)<br>放在类定义上，可以在该类对象序列化的时候，字段按照字母序排序。<br>全局的话，可以这样配置Jackson的mapper：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAPPER.configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true);</span><br><span class="line">MAPPER.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true);</span><br></pre></td></tr></table></figure><p></p><p>问题来了，<br>如果类中的字段是不确定类型的（或者说是Object类型），该类型的字段中又可以嵌套其他不确定类型，这样就不好办了，<br>而我要达到的需求是，所有嵌套结构内部也要按照字母序，或者叫严格的字母序。</p><p>经验证，在不使用JsonNode的情况下，MAPPER的configure可以满足大多数需求。那么，为什么要用JsonNode呢？</p><p>在数据交换的时候，例如反序列化的时候，不知道某个字段的具体类型，是否有嵌套等，用JsonNode会比Map这种好很多，Map不太好处理嵌套的情况。<br>也有同学提出直接使用Object也可以呀，那就会丢失太多的类型信息，内部字段和深层嵌套就更没法处理了。<br>使用JsonNode可以构建出树状结构，很方便的获取属性值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JsonNode node = MAPPER.valueToTree(obj);</span><br><span class="line">final Object obj = MAPPER.treeToValue(node, Object.class);</span><br><span class="line">String json = MAPPER.writeValueAsString(obj);</span><br></pre></td></tr></table></figure><p>参考文档：<br><a href="https://stackoverflow.com/questions/18952571/jackson-jsonnode-to-string-with-sorted-keys#" target="_blank" rel="noopener">https://stackoverflow.com/questions/18952571/jackson-jsonnode-to-string-with-sorted-keys#</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经常使用Jackson的同学肯定知道这个注解，&lt;br&gt;@JsonPropertyOrder(alphabetic = true)&lt;br&gt;放在类定义上，可以在该类对象序列化的时候，字段按照字母序排序。&lt;br&gt;全局的话，可以这样配置Jackson的mapper：&lt;br&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Docker-Basic</title>
    <link href="https://leicode.com/posts/a02e5c6b/"/>
    <id>https://leicode.com/posts/a02e5c6b/</id>
    <published>2018-01-25T07:45:10.000Z</published>
    <updated>2018-09-07T07:18:29.691Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于生产环境的上线部署，都依赖于镜像构建、制作、部署上线运行等操作，作为一名合格的RD，当然不能只局限于在上线平台上进行一顿鼠标操作了，一定要弄懂这些基础设施内部到底在干嘛。因此，对Docker的相关学习也是很有必要的。</p><h1 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h1><p><a href="http://dockone.io/article/783" target="_blank" rel="noopener">http://dockone.io/article/783</a></p><p><a href="http://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html" target="_blank" rel="noopener">http://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html</a></p><p>两篇文章分别是中文和英文原版，建议初学者多读几遍，收获非常大。<br>尤其是对镜像只读层和读写层的理解，非常重要，还有docker各个命令对各层的影响。<br><a id="more"></a></p><h1 id="Docker-run"><a href="#Docker-run" class="headerlink" title="Docker run"></a>Docker run</h1><p><a href="https://docs.docker.com/engine/reference/commandline/run/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/run/</a></p><p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p><p>常用选项：</p><ul><li>–detach , -d Run container in background and print container ID</li><li>–tty , -t Allocate a pseudo-TTY</li><li>–interactive , -i Keep STDIN open even if not attached</li><li>–publish , -p Publish a container’s port(s) to the host</li><li>–volume , -v Bind mount a volume</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// sshd -D 将 sshd 作为前台进程运行，而不是脱离控制台成为后台守护进程。主要用于调试。</span><br><span class="line">// -it 通常一起使用，可以开启一个终端进去交互模式，调试时很有用。</span><br><span class="line">docker run -d -p 2222:22 tomcat:centos /usr/sbin/sshd -D</span><br><span class="line"></span><br><span class="line">docker run -ti -v ~/Downloads:/Downloads tomcat:centos /bin/bash</span><br><span class="line"></span><br><span class="line">docker run -d -p 8000:8080 -p 1098:1099 tomcat:centos /usr/local/sbin/tomcat.sh</span><br><span class="line"></span><br><span class="line">docker run -it -p 8000:8080 -p 1098:1099 tomcat:centos /usr/local/sbin/tomcat.sh</span><br></pre></td></tr></table></figure><h1 id="其他Docker命令"><a href="#其他Docker命令" class="headerlink" title="其他Docker命令"></a>其他Docker命令</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ul><li>docker version</li><li>docker info</li><li>docker stop $(docker ps -aq)</li><li>docker rm $(docker ps -aq)</li><li>docker pull</li><li>docker login</li><li>docerk rmi</li><li>docker images</li></ul><h2 id="镜像类"><a href="#镜像类" class="headerlink" title="镜像类"></a>镜像类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 检索image</span><br><span class="line">$docker search image_name</span><br><span class="line"></span><br><span class="line"># 下载image</span><br><span class="line">$docker pull image_name</span><br><span class="line"></span><br><span class="line"># 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don&apos;t truncate output; -q, --quiet=false Only show numeric IDs</span><br><span class="line">$docker images</span><br><span class="line"></span><br><span class="line"># 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents</span><br><span class="line">$docker rmi image_name</span><br><span class="line"></span><br><span class="line"># 显示一个镜像的历史; --no-trunc=false Don&apos;t truncate output; -q, --quiet=false Only show numeric IDs</span><br><span class="line">$docker history image_name</span><br></pre></td></tr></table></figure><h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 列出当前所有正在运行的container</span><br><span class="line">$docker ps</span><br><span class="line"># 列出所有的container</span><br><span class="line">$docker ps -a</span><br><span class="line"># 列出最近一次启动的container</span><br><span class="line">$docker ps -l</span><br><span class="line"></span><br><span class="line"># 保存对容器的修改; -a, --author=&quot;&quot; Author; -m, --message=&quot;&quot; Commit message  </span><br><span class="line">$docker commit ID new_image_name</span><br><span class="line"></span><br><span class="line"># 删除所有容器</span><br><span class="line">$docker rm `docker ps -a -q`</span><br><span class="line">  </span><br><span class="line"># 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container</span><br><span class="line">$docker rm Name/ID</span><br><span class="line"></span><br><span class="line"># 停止、启动、杀死一个容器</span><br><span class="line">$docker stop Name/ID</span><br><span class="line">$docker start Name/ID</span><br><span class="line">$docker kill Name/ID</span><br><span class="line"></span><br><span class="line"># 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps</span><br><span class="line">$docker logs Name/ID</span><br><span class="line">  </span><br><span class="line"># 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的</span><br><span class="line">$docker diff Name/ID</span><br><span class="line">  </span><br><span class="line"># 显示一个运行的容器里面的进程信息</span><br><span class="line">$docker top Name/ID</span><br><span class="line"></span><br><span class="line"># 从容器里面拷贝文件/目录到本地一个路径  </span><br><span class="line">$docker cp Name:/container_path to_path</span><br><span class="line">$docker cp ID:/container_path to_path</span><br><span class="line"></span><br><span class="line"># 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10</span><br><span class="line">$docker restart Name/ID</span><br><span class="line"></span><br><span class="line"># 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process  </span><br><span class="line">$docker attach ID</span><br></pre></td></tr></table></figure><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>to be continued</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鉴于生产环境的上线部署，都依赖于镜像构建、制作、部署上线运行等操作，作为一名合格的RD，当然不能只局限于在上线平台上进行一顿鼠标操作了，一定要弄懂这些基础设施内部到底在干嘛。因此，对Docker的相关学习也是很有必要的。&lt;/p&gt;&lt;h1 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://dockone.io/article/783&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dockone.io/article/783&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;两篇文章分别是中文和英文原版，建议初学者多读几遍，收获非常大。&lt;br&gt;尤其是对镜像只读层和读写层的理解，非常重要，还有docker各个命令对各层的影响。&lt;br&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://leicode.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Hexo启用Https后设置腾讯公益404的问题</title>
    <link href="https://leicode.com/posts/da5ea02e/"/>
    <id>https://leicode.com/posts/da5ea02e/</id>
    <published>2017-08-30T07:12:16.000Z</published>
    <updated>2018-09-07T07:18:29.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h2><p>执行<br>hexo new page 404</p><h2 id="修改source-404-index-md"><a href="#修改source-404-index-md" class="headerlink" title="修改source/404/index.md"></a>修改source/404/index.md</h2><p>一些老的页面会出现问题，因为启用了Https后，去加载Http的样式表和JS会失败，所以要使用以下的页面代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 404</span><br><span class="line">date: 2018-08-30 14:40:55</span><br><span class="line">---</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-cn&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">  &lt;title&gt;404&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; homePageName=&quot;返回宝贝回家&quot; homePageUrl=&quot;https://www.baobeihuijia.com&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;新建页面&quot;&gt;&lt;a href=&quot;#新建页面&quot; class=&quot;headerlink&quot; title=&quot;新建页面&quot;&gt;&lt;/a&gt;新建页面&lt;/h2&gt;&lt;p&gt;执行&lt;br&gt;hexo new page 404&lt;/p&gt;&lt;h2 id=&quot;修改source-404-index-md&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="网站" scheme="https://leicode.com/categories/%E7%BD%91%E7%AB%99/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo Basic Usage</title>
    <link href="https://leicode.com/posts/f49afeaf/"/>
    <id>https://leicode.com/posts/f49afeaf/</id>
    <published>2016-05-18T06:26:50.000Z</published>
    <updated>2018-09-07T07:18:29.700Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><br><a id="more"></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>工作一年的技术成长总结</title>
    <link href="https://leicode.com/posts/4d806b6d/"/>
    <id>https://leicode.com/posts/4d806b6d/</id>
    <published>2016-04-20T07:25:21.000Z</published>
    <updated>2018-09-07T07:18:29.689Z</updated>
    
    <content type="html"><![CDATA[<p>工作一年多以来，学了不少东西，也尝试了许多新东西，也成长了不少，也许只是一个粗略的记录，也希望提醒自己，还是取得了一些成绩吧，但不能骄傲，还有许多不足之处，技术永无止境，还需要更多的努力。<br><a id="more"></a></p><p>工作初始，接触的是C语言网络编程和后台编程的项目，承担的是整体系统中的一部分，加上之前对Redis的了解，也比较适合在这里使用，在设计的时候也就用上了。因为的自己负责调研的部分，所以许多都可以自己设计，还是很高兴的，在使用Redis的过程中，也简单分析了Redis的代码，以及在Linux下编程的技巧，包括学习Redis的Makefile，对错误和消息的处理等。使用Redis作为缓存队列，也实现了自己想要的效果，当然这里会有更优的解决方案，但是作为自己在项目中的第一个设计，还是基本满意的。</p><p>再后来的项目，大部分的经历就转到Java语言项目和Java Web方面了，也接触了一些项目的框架，修改功能代码等。独当一面的是另外一个基于大数据的演示性项目，将来会把这个搭建在服务器上。这个项目里，我独立完成了项目的Java Web后台设计，使用了包括Spring，Struts，MongoDB，Morphia等技术，独立设计前台HTML和JS等，使用了Bootstrap，Echarts，JQuery，Semantic-ui等。项目的时间比较久，后来还有一些改进方案没来得及实施，但是从我的角度来说，是我的一个大作品。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作一年多以来，学了不少东西，也尝试了许多新东西，也成长了不少，也许只是一个粗略的记录，也希望提醒自己，还是取得了一些成绩吧，但不能骄傲，还有许多不足之处，技术永无止境，还需要更多的努力。&lt;br&gt;
    
    </summary>
    
      <category term="Diary" scheme="https://leicode.com/categories/Diary/"/>
    
    
  </entry>
  
</feed>
