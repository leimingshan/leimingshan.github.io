<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mingshan Lei&#39;s Blog</title>
  
  <subtitle>雷鸣山的技术分享博客</subtitle>
  <link href="https://leicode.com/atom.xml" rel="self"/>
  
  <link href="https://leicode.com/"/>
  <updated>2021-07-11T10:36:39.488Z</updated>
  <id>https://leicode.com/</id>
  
  <author>
    <name>Mingshan Lei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>两个小目标</title>
    <link href="https://leicode.com/posts/c3d34c8/"/>
    <id>https://leicode.com/posts/c3d34c8/</id>
    <published>2021-07-11T09:48:38.000Z</published>
    <updated>2021-07-11T10:36:39.488Z</updated>
    
    <content type="html"><![CDATA[<p>害，这里本来就并不应该是纯技术博客嘛，也可以有生活，对不对，用阿里的土话说，认真生活，快乐工作。生活一直都应该是很重要的一部分才对！</p><span id="more"></span><p>记得以前很早很早的时候，07年刚上大学那会儿吧，在新浪博客（曾经特别火，跟现在的微博似的），还可以看到很多人的内容非常丰富的文章，记录自己每天的所思所想，甚至有点日记的意思。时过境迁，现在几乎没有人再写长的生活类博客，在cnblog这些地方残留的也基本都是技术文章了，其他都被微博和朋友圈替代了，就像长视频被短视频替代一样，大家的生活节奏越来越快，注意力的时间越来越短，心里也越来越急躁，渐渐的就出现了这样的转变吧。</p><p>可我还是愿意做一个可以慢慢思考的人，从去年底到2021年的上半年，经历了好多好多事情，都没有记录下来，这里不是想记录下经历的每一件事情，而是想沉淀自己的思考，回望自己的改变，有变的更好吗，是自己期望的吗，还能做的更好吗，过去不能改变，但希望，将来我能变的更好。</p><p>那么就先给自己定下两个小目标吧：</p><ol><li>用照片记录生活 - 学会摄影</li><li>用文字记录生活 - 坚持写作</li></ol><pre><code>无论过去因为我们不能改变过去不问将来因为将来一定会因我们而改变   -- 时光代理人</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;害，这里本来就并不应该是纯技术博客嘛，也可以有生活，对不对，用阿里的土话说，认真生活，快乐工作。生活一直都应该是很重要的一部分才对！&lt;/p&gt;</summary>
    
    
    
    <category term="我自己" scheme="https://leicode.com/categories/%E6%88%91%E8%87%AA%E5%B7%B1/"/>
    
    
    <category term="我自己" scheme="https://leicode.com/tags/%E6%88%91%E8%87%AA%E5%B7%B1/"/>
    
    <category term="思考" scheme="https://leicode.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Java-LinkedHashMap解析</title>
    <link href="https://leicode.com/posts/27758f4f/"/>
    <id>https://leicode.com/posts/27758f4f/</id>
    <published>2021-07-11T09:36:27.000Z</published>
    <updated>2021-07-11T09:39:08.320Z</updated>
    
    <content type="html"><![CDATA[<p>这周也是抽空复习了下数据结构，也对Java中比较常见的几个重新熟悉了下，之前虽然会用也都有了解，还是有些不太深刻的地方，今天就一起总结下吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这周也是抽空复习了下数据结构，也对Java中比较常见的几个重新熟悉了下，之前虽然会用也都有了解，还是有些不太深刻的地方，今天就一起总结下吧。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>执行力（Executive Ability）</title>
    <link href="https://leicode.com/posts/ffaefb69/"/>
    <id>https://leicode.com/posts/ffaefb69/</id>
    <published>2021-06-25T15:03:22.000Z</published>
    <updated>2021-06-25T15:10:54.162Z</updated>
    
    <content type="html"><![CDATA[<p>每当你稍微感觉自己有点懒惰的时候，想都不要想地放下当下手里所有的事，立刻开始做你最不想做却不得不做的那件事。</p><p>最核心的点在于</p><ol><li>稍有懒惰的萌芽就要立刻放下当下手里的任何事（视频，音乐，社交软件，被窝等等），立刻马上。</li><li>这个过程中脑袋里什么都不要想。因为我们生活中绝大部分需要完成的事情，其中80%的精力都消耗在启动这个环节。所以，当你用一种势不可挡的态度在极短的时间内完成了这80%，剩下20%靠惯性就可以了。<span id="more"></span>永远永远都不要说我从下个礼拜/明天/一小时以后/半小时以后/二十分钟以后/十分钟以后/五分钟以后再开始，就是现在这一秒！否则就真的明日复明日了。</li></ol><p>这个方法有个bonus，就是很刺激。你想像一下上一秒还在娱乐懒惰，这一秒就开始做正经事，这种突如其来的角色反差造成的心灵冲击力足以让你脱胎换骨，等你什么时候习惯这种反差了，你的拖延症就治好了。其实用这个方法不一定能让你高质量地完成所有事，但最珍贵的是通过这样的训练让你养成了一个一直在做优先级最高的事情的习惯。无论你未来励志做科学家，CEO，还是国家主席，养成这个习惯都是你的入门课。</p><p>都看到这了，赶紧放下手机滚去学习吧！</p><p>参考：<a href="https://www.zhihu.com/question/52723910/answer/132211549">https://www.zhihu.com/question/52723910/answer/132211549</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;每当你稍微感觉自己有点懒惰的时候，想都不要想地放下当下手里所有的事，立刻开始做你最不想做却不得不做的那件事。&lt;/p&gt;
&lt;p&gt;最核心的点在于&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;稍有懒惰的萌芽就要立刻放下当下手里的任何事（视频，音乐，社交软件，被窝等等），立刻马上。&lt;/li&gt;
&lt;li&gt;这个过程中脑袋里什么都不要想。因为我们生活中绝大部分需要完成的事情，其中80%的精力都消耗在启动这个环节。所以，当你用一种势不可挡的态度在极短的时间内完成了这80%，剩下20%靠惯性就可以了。</summary>
    
    
    
    
    <category term="我自己" scheme="https://leicode.com/tags/%E6%88%91%E8%87%AA%E5%B7%B1/"/>
    
    <category term="思考" scheme="https://leicode.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Hexo升级指南</title>
    <link href="https://leicode.com/posts/d9017f30/"/>
    <id>https://leicode.com/posts/d9017f30/</id>
    <published>2021-06-25T13:58:36.000Z</published>
    <updated>2021-06-25T15:04:34.212Z</updated>
    
    <content type="html"><![CDATA[<p>太久没回来更新的后果之一，就是整个博客的技术栈已经完全outdate了，需要进行大的升级，NodeJS要升级，Hexo和Next theme都要进行几个大版本的升级。几个简要的步骤记录下吧，用得上的同学自取哦。</p><span id="more"></span><h1 id="Node的升级"><a href="#Node的升级" class="headerlink" title="Node的升级"></a>Node的升级</h1><p>因为之前用的nvm，就比较简单，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote</span><br><span class="line">nvm install --lts     #安装最新的lts版本吧，比较推荐</span><br><span class="line">nvm ls                #查看现在安装的哪些版本</span><br><span class="line">nvm uninstall v8.12.0 #找到旧的版本删除掉吧</span><br></pre></td></tr></table></figure><h1 id="Hexo的升级"><a href="#Hexo的升级" class="headerlink" title="Hexo的升级"></a>Hexo的升级</h1><ol><li>全局升级hexo-cli，先hexo version查看当前版本，然后npm install -g hexo-cli，再次hexo version查看是否升级成功。如果hexo不能直接识别运行，改为npx hexo。</li><li>使用npm-check，检查系统中的插件是否有升级的。</li><li>使用npm-upgrade，升级系统中的相关插件。</li><li>npm update -g，检查升级npm本身。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo version</span><br><span class="line"></span><br><span class="line">npm install -g npm-check</span><br><span class="line">npm-check</span><br><span class="line"></span><br><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-upgrade</span><br><span class="line"></span><br><span class="line">npm update -g</span><br><span class="line">npm install -g npm</span><br><span class="line"></span><br><span class="line">hexo clean #清理hexo数据并重新生成页面并部署</span><br><span class="line">hexo g -s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>经过以上这些命令，整体翻新就差不多了，theme的升级，我这边是删除了原来的主题目录，重新进行了拉取，注意保留配置文件，重新配置即可，就不详述了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;太久没回来更新的后果之一，就是整个博客的技术栈已经完全outdate了，需要进行大的升级，NodeJS要升级，Hexo和Next theme都要进行几个大版本的升级。几个简要的步骤记录下吧，用得上的同学自取哦。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="JavaScript" scheme="https://leicode.com/tags/JavaScript/"/>
    
    <category term="NodeJs" scheme="https://leicode.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>无问西东</title>
    <link href="https://leicode.com/posts/5dc2f86c/"/>
    <id>https://leicode.com/posts/5dc2f86c/</id>
    <published>2021-06-22T00:57:16.000Z</published>
    <updated>2021-06-25T15:12:03.180Z</updated>
    
    <content type="html"><![CDATA[<p>如果提前了解了你所面对的人生，你是否还有勇气前来？</p><p>如果你明知道努力无法改变任何结果，你是否还愿意去努力？</p><span id="more"></span><p>What’s happened’s happened. Which is an expression of faith in the mechanics of the world. It’s not an excuse to do nothing.<br>发生过的事已经发生了。这是对这个世界运作的信念，而不是袖手旁观的借口。</p><p>愿你在被打击时，记起你的珍贵，抵抗恶意；愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。</p><p>身边的人都很好，没有人有恶意，只是很多时候，我们都处于迷茫之中，拼了命的想找到一个明确的方向，结果到处碰壁，撞的头破血流，倒不如Follow your heart，让你的内心指引你，找到那条属于你自己的道路。</p><p>爱你所爱，行你所行，听从你心，无问西东。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果提前了解了你所面对的人生，你是否还有勇气前来？&lt;/p&gt;
&lt;p&gt;如果你明知道努力无法改变任何结果，你是否还愿意去努力？&lt;/p&gt;</summary>
    
    
    
    <category term="我自己" scheme="https://leicode.com/categories/%E6%88%91%E8%87%AA%E5%B7%B1/"/>
    
    
    <category term="我自己" scheme="https://leicode.com/tags/%E6%88%91%E8%87%AA%E5%B7%B1/"/>
    
    <category term="思考" scheme="https://leicode.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>I am back</title>
    <link href="https://leicode.com/posts/1a3b783e/"/>
    <id>https://leicode.com/posts/1a3b783e/</id>
    <published>2021-06-20T04:13:33.000Z</published>
    <updated>2021-06-25T15:08:20.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我回来了"><a href="#我回来了" class="headerlink" title="我回来了"></a>我回来了</h1><p>不知不觉离开了好久呀，2年半的时间，跟我在蚂蚁工作的时间一样长，这两年经历了很多，其实有很多可以分享记录一下，所以趁现在记忆还清晰，最近会留下一些小思考，记录一下自己的成长吧。</p><p>分享一段罗翔老师的话，读《小王子》有感：<br>在芸芸众生之中，我们看似自己选择。但其实是被命运之手安排。</p><span id="more"></span><p>我们爱上了一个人，我们选择了或者说我们被选择了，在一个具体的个体身上投放我们的时间，通过各种的仪式，我驯化了她，她也驯化了我。<br>我们开始经营，在经营的过程中是会被刺伤的，是会流泪的是会痛苦的。</p><p>但是有一天，我们爱上了，那风吹麦浪的声音，我们看到了她的与众不同，正是因为这种美好、我们愿意为我们所驯服的对象负责，即便，让我们像小王子那样，为了找回那朵玫瑰他甚至不惜牺牲自己的生命，也许这就是爱吧。</p><p>爱肯定不是一个单纯的欲望的满足，因为欲望的满足，会让人觉得无限的空虚，爱一定是在一个具体的个体身上。投入你的感情，你的时间，所以感恩，我们能够与我们爱的人相遇，我们也感恩在我们爱的人的身上，我们愿意活出我们的美好。不是吗？</p><p>玫瑰花是我能看见的，这是一个具体，但是看不见美丽，那是抽象的，我们终究一生都是在具体的个体上，我们看见了我们看不见的美好和责任。我们把我们的责任，把我们的幸福放在具体的人身上，虽然具体的人是带刺的，具体的人并不一定有我们想象中那么美好，但是正是因为她没有我们想象中那么美好，所以我们要和她一起来吧那个看不见的圆给画好。</p><p>当你找到那朵玫瑰花，请注意真正的爱，是要用时间，用真心，用责任，用牺牲 去守护。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;我回来了&quot;&gt;&lt;a href=&quot;#我回来了&quot; class=&quot;headerlink&quot; title=&quot;我回来了&quot;&gt;&lt;/a&gt;我回来了&lt;/h1&gt;&lt;p&gt;不知不觉离开了好久呀，2年半的时间，跟我在蚂蚁工作的时间一样长，这两年经历了很多，其实有很多可以分享记录一下，所以趁现在记忆还清晰，最近会留下一些小思考，记录一下自己的成长吧。&lt;/p&gt;
&lt;p&gt;分享一段罗翔老师的话，读《小王子》有感：&lt;br&gt;在芸芸众生之中，我们看似自己选择。但其实是被命运之手安排。&lt;/p&gt;</summary>
    
    
    
    <category term="我自己" scheme="https://leicode.com/categories/%E6%88%91%E8%87%AA%E5%B7%B1/"/>
    
    
    <category term="我自己" scheme="https://leicode.com/tags/%E6%88%91%E8%87%AA%E5%B7%B1/"/>
    
    <category term="思考" scheme="https://leicode.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Redis Lua script</title>
    <link href="https://leicode.com/posts/5ba98ff9/"/>
    <id>https://leicode.com/posts/5ba98ff9/</id>
    <published>2018-12-25T08:44:15.000Z</published>
    <updated>2018-12-25T10:20:33.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-Lua脚本的几种应用场景"><a href="#Redis-Lua脚本的几种应用场景" class="headerlink" title="Redis Lua脚本的几种应用场景"></a>Redis Lua脚本的几种应用场景</h1><h2 id="批量删除符合某种pattern的keys"><a href="#批量删除符合某种pattern的keys" class="headerlink" title="批量删除符合某种pattern的keys"></a>批量删除符合某种pattern的keys</h2><p>bin/redis-cli eval “return redis.call(“del”,unpack(redis.call(“keys”,ARGV[1])))” 0 “HelloWorld*”<br>该命令会删除所有以HelloWorld开头的keys。</p><h2 id="迁移db-index的lua脚本"><a href="#迁移db-index的lua脚本" class="headerlink" title="迁移db index的lua脚本"></a>迁移db index的lua脚本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local result=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">local keys =redis.call(&quot;keys&quot;,&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">for i = 1, #keys do</span><br><span class="line">  local val= redis.call(&quot;move&quot;, keys[i], 0);</span><br><span class="line">end</span><br><span class="line">return  result;</span><br></pre></td></tr></table></figure><p>以上也是很常见的一种脚本范式，先根据需要查询获取到所有的key，再遍历这些key进行想要的操作，例如move, del, rename等等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis-Lua脚本的几种应用场景&quot;&gt;&lt;a href=&quot;#Redis-Lua脚本的几种应用场景&quot; class=&quot;headerlink&quot; title=&quot;Redis Lua脚本的几种应用场景&quot;&gt;&lt;/a&gt;Redis Lua脚本的几种应用场景&lt;/h1&gt;&lt;h2 id=&quot;批</summary>
      
    
    
    
    <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="NoSQL" scheme="https://leicode.com/tags/NoSQL/"/>
    
    <category term="Redis" scheme="https://leicode.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS - How to update packages by npm</title>
    <link href="https://leicode.com/posts/595239dd/"/>
    <id>https://leicode.com/posts/595239dd/</id>
    <published>2018-10-22T05:06:27.000Z</published>
    <updated>2018-10-23T06:23:20.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NVM安装新版本node之后的-global-packages-迁移"><a href="#NVM安装新版本node之后的-global-packages-迁移" class="headerlink" title="NVM安装新版本node之后的 global packages 迁移"></a>NVM安装新版本node之后的 global packages 迁移</h1><p>NVM安装新版本node之后，全局的package需要迁移，注意使用以下命令，这样就不用手动一个个安装global package了。<br>例如我今天安装了v8.12.0的node，之前的版本是v8.11.3，那么执行以下命令就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nvm install v8.12.0</span><br><span class="line">nvm reinstall-packages v8.11.3  # 把在v8.11.3版本node下安装的全部global package安装到新的node下面</span><br><span class="line">nvm uninstall v8.11.3</span><br><span class="line">nvm install-latest-npm          # 顺便更新一下npm</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="更新-global-packages"><a href="#更新-global-packages" class="headerlink" title="更新 global packages"></a>更新 global packages</h1><p>npm update -g</p><p>参考：<a href="https://docs.npmjs.com/getting-started/updating-global-packages">https://docs.npmjs.com/getting-started/updating-global-packages</a></p><h1 id="更新-local-packages"><a href="#更新-local-packages" class="headerlink" title="更新 local packages"></a>更新 local packages</h1><p>npm outdated 会列出所有可更新的 node_modules。<br>npm update 更新命令，只能按照package.js中标注的版本号，进行更新，所以每次都要改下package.js中的版本号为最新才能够更新，太麻烦。<br>那还有没有更好的办法呢，当然有，就是借助升级插件npm-check-updates</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check-updates</span><br><span class="line">ncu     # 查看全部需要更新的包和最新版本</span><br><span class="line">ncu -a  # 更新全部依赖到最新版本，并覆盖package.js</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://docs.npmjs.com/getting-started/updating-local-packages">https://docs.npmjs.com/getting-started/updating-local-packages</a></li><li><a href="https://www.npmjs.com/package/npm-check-updates">https://www.npmjs.com/package/npm-check-updates</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;NVM安装新版本node之后的-global-packages-迁移&quot;&gt;&lt;a href=&quot;#NVM安装新版本node之后的-global-packages-迁移&quot; class=&quot;headerlink&quot; title=&quot;NVM安装新版本node之后的 global packages 迁移&quot;&gt;&lt;/a&gt;NVM安装新版本node之后的 global packages 迁移&lt;/h1&gt;&lt;p&gt;NVM安装新版本node之后，全局的package需要迁移，注意使用以下命令，这样就不用手动一个个安装global package了。&lt;br&gt;例如我今天安装了v8.12.0的node，之前的版本是v8.11.3，那么执行以下命令就可以了。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nvm install v8.12.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nvm reinstall-packages v8.11.3  # 把在v8.11.3版本node下安装的全部global package安装到新的node下面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nvm uninstall v8.11.3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nvm install-latest-npm          # 顺便更新一下npm&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="JavaScript" scheme="https://leicode.com/tags/JavaScript/"/>
    
    <category term="NodeJs" scheme="https://leicode.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript RSA encrypt 公钥加密</title>
    <link href="https://leicode.com/posts/725aae6c/"/>
    <id>https://leicode.com/posts/725aae6c/</id>
    <published>2018-10-19T03:30:57.000Z</published>
    <updated>2018-10-19T05:10:25.554Z</updated>
    
    <content type="html"><![CDATA[<p>在前端与后端交互的过程中，很可能会遇到使用RSA公钥加密，然后用私钥解密的情况，<br>RSA的私钥签名，公钥验签同样也很常用，这里简单介绍一下 JavaScript 语言RSA算法的一些解决方案。</p><h1 id="NodeJs环境"><a href="#NodeJs环境" class="headerlink" title="NodeJs环境"></a>NodeJs环境</h1><p>可以直接引入NodeJs自带的crypto模块，基于RSA/ECB/PKCS1Padding加密，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const crypto = require(&#x27;crypto&#x27;);</span><br><span class="line">private RSAEncrypt(rsakey:string, text:string)&#123;</span><br><span class="line">    let encrypted = crypto.publicEncrypt(&#123;key:rsakey,</span><br><span class="line">        padding:crypto.constants.RSA_PKCS1_PADDING&#125;,new Buffer(text)).toString(&#x27;base64&#x27;);</span><br><span class="line">    return encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中rsakey为pem格式的公钥，可以从文件读取，或者指定字符串，字符串格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsakey=&#x27;-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCm5IN1uRvak0Kod3YviD/b67dj\nzP/ubU+8RgbCnm1HUVYBAVGnvg5epMfGunXKFXSb1ehOvQ2K+fEJLa+pKy2uLZLd\n/6gbUGJn+q8wGiFKfu0U0H3E+2yH6eFX+IPXx5OJNwUE6yqKR6hOBz5qR/AtVRfM\n6aAcDLIR7wE06SnHVQIDAQAB\n-----END PUBLIC KEY-----\n&#x27;</span><br></pre></td></tr></table></figure><p>text就是准备加密的字符串了，直接调用该方法就可以完成加密过程。</p><p>参考：<a href="https://nodejs.org/docs/latest-v8.x/api/crypto.html#crypto_crypto_publicencrypt_key_buffer">https://nodejs.org/docs/latest-v8.x/api/crypto.html#crypto_crypto_publicencrypt_key_buffer</a></p><h1 id="JavaScript-native-or-a-web-browser"><a href="#JavaScript-native-or-a-web-browser" class="headerlink" title="JavaScript native or a web browser"></a>JavaScript native or a web browser</h1><p>如果是单纯的浏览器环境，推荐<a href="https://github.com/digitalbazaar/forge">forge.js</a>。<br>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;JavaScript RSA Encryption&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;http://code.jquery.com/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/node-forge@0.7.0/dist/forge.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">      // Call this code when the page is done loading.</span><br><span class="line">      $(function() &#123;</span><br><span class="line"></span><br><span class="line">        // Run a quick encryption/decryption when they click.</span><br><span class="line">        $(&#x27;#testme&#x27;).click(function() &#123;</span><br><span class="line"></span><br><span class="line">          var publicKey = forge.pki.publicKeyFromPem($(&#x27;#pubkey&#x27;).val());</span><br><span class="line"></span><br><span class="line">          // convert string to UTF-8 encoded bytes</span><br><span class="line">          var buffer = forge.util.createBuffer($(&#x27;#input&#x27;).val());</span><br><span class="line">          var bytes = buffer.getBytes();</span><br><span class="line"></span><br><span class="line">          // encrypt data with a public key using RSAES PKCS#1 v1.5</span><br><span class="line">          var encrypted = publicKey.encrypt(bytes, &#x27;RSAES-PKCS1-V1_5&#x27;);</span><br><span class="line"></span><br><span class="line">          // base64-encode encrypted data to send to server</span><br><span class="line">          var b64Encoded = forge.util.encode64(encrypted);</span><br><span class="line">          console.log(b64Encoded);</span><br><span class="line">          alert(b64Encoded);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;label for=&quot;pubkey&quot;&gt;Public Key&lt;/label&gt;&lt;br/&gt;</span><br><span class="line">    &lt;textarea id=&quot;pubkey&quot; rows=&quot;15&quot; cols=&quot;65&quot;&gt;-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDY08fkt9d32KHV1JapaZGtk+fL</span><br><span class="line">a7wvxMAdZ0oENhx6HgBisSlDwCgBfRtN5l2iOjKm+eByp7Od24JqIOwgDF6FZ/ol</span><br><span class="line">CQbnXjzPhG0EOeLnu3AXntzhu9A0yS7b3p+pxGR7EvhIz1xkOS4bNABsAgF7Y5Zu</span><br><span class="line">B1RpsOZZdxNHGeStBwIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----&lt;/textarea&gt;&lt;br/&gt;</span><br><span class="line">    &lt;label for=&quot;input&quot;&gt;Text to encrypt:&lt;/label&gt;&lt;br/&gt;</span><br><span class="line">    &lt;textarea id=&quot;input&quot; name=&quot;input&quot; type=&quot;text&quot; rows=4 cols=70&gt;Hello World!&lt;/textarea&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input id=&quot;testme&quot; type=&quot;button&quot; value=&quot;RSA Encrypt&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://github.com/digitalbazaar/forge">https://github.com/digitalbazaar/forge</a></li><li><a href="https://github.com/digitalbazaar/forge/issues/407">https://github.com/digitalbazaar/forge/issues/407</a></li></ul><span id="more"></span><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>最后以我最熟悉的JAVA举例，直接使用java.security的几个相关类即可，列举几个关键的方法吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static final String CIPHER_TRANSFORMATION = &quot;RSA/ECB/PKCS1Padding&quot;;</span><br><span class="line">public static final String CIPHER_ALGORITHM = &quot;RSA&quot;;</span><br><span class="line"></span><br><span class="line">Cipher cipher = Cipher.getInstance(CIPHER_TRANSFORMATION);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, getRSAPublicKeyFromStr(publicKeyStr));</span><br><span class="line">byte[] encryptedData = cipher.doFinal(data);</span><br><span class="line"></span><br><span class="line">String encryptedStr = Base64.getEncoder().encodeToString(encryptedData);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前端与后端交互的过程中，很可能会遇到使用RSA公钥加密，然后用私钥解密的情况，&lt;br&gt;RSA的私钥签名，公钥验签同样也很常用，这里简单介绍一下 JavaScript 语言RSA算法的一些解决方案。&lt;/p&gt;
&lt;h1 id=&quot;NodeJs环境&quot;&gt;&lt;a href=&quot;#NodeJs环境&quot; class=&quot;headerlink&quot; title=&quot;NodeJs环境&quot;&gt;&lt;/a&gt;NodeJs环境&lt;/h1&gt;&lt;p&gt;可以直接引入NodeJs自带的crypto模块，基于RSA/ECB/PKCS1Padding加密，用法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const crypto = require(&amp;#x27;crypto&amp;#x27;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private RSAEncrypt(rsakey:string, text:string)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let encrypted = crypto.publicEncrypt(&amp;#123;key:rsakey,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        padding:crypto.constants.RSA_PKCS1_PADDING&amp;#125;,new Buffer(text)).toString(&amp;#x27;base64&amp;#x27;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return encrypted;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中rsakey为pem格式的公钥，可以从文件读取，或者指定字符串，字符串格式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rsakey=&amp;#x27;-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCm5IN1uRvak0Kod3YviD/b67dj\nzP/ubU+8RgbCnm1HUVYBAVGnvg5epMfGunXKFXSb1ehOvQ2K+fEJLa+pKy2uLZLd\n/6gbUGJn+q8wGiFKfu0U0H3E+2yH6eFX+IPXx5OJNwUE6yqKR6hOBz5qR/AtVRfM\n6aAcDLIR7wE06SnHVQIDAQAB\n-----END PUBLIC KEY-----\n&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;text就是准备加密的字符串了，直接调用该方法就可以完成加密过程。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://nodejs.org/docs/latest-v8.x/api/crypto.html#crypto_crypto_publicencrypt_key_buffer&quot;&gt;https://nodejs.org/docs/latest-v8.x/api/crypto.html#crypto_crypto_publicencrypt_key_buffer&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;JavaScript-native-or-a-web-browser&quot;&gt;&lt;a href=&quot;#JavaScript-native-or-a-web-browser&quot; class=&quot;headerlink&quot; title=&quot;JavaScript native or a web browser&quot;&gt;&lt;/a&gt;JavaScript native or a web browser&lt;/h1&gt;&lt;p&gt;如果是单纯的浏览器环境，推荐&lt;a href=&quot;https://github.com/digitalbazaar/forge&quot;&gt;forge.js&lt;/a&gt;。&lt;br&gt;代码示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!doctype html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;head&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;title&amp;gt;JavaScript RSA Encryption&amp;lt;/title&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;script src=&amp;quot;http://code.jquery.com/jquery-1.8.3.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;script src=&amp;quot;https://cdn.jsdelivr.net/npm/node-forge@0.7.0/dist/forge.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      // Call this code when the page is done loading.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      $(function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Run a quick encryption/decryption when they click.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        $(&amp;#x27;#testme&amp;#x27;).click(function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          var publicKey = forge.pki.publicKeyFromPem($(&amp;#x27;#pubkey&amp;#x27;).val());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          // convert string to UTF-8 encoded bytes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          var buffer = forge.util.createBuffer($(&amp;#x27;#input&amp;#x27;).val());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          var bytes = buffer.getBytes();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          // encrypt data with a public key using RSAES PKCS#1 v1.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          var encrypted = publicKey.encrypt(bytes, &amp;#x27;RSAES-PKCS1-V1_5&amp;#x27;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          // base64-encode encrypted data to send to server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          var b64Encoded = forge.util.encode64(encrypted);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          console.log(b64Encoded);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          alert(b64Encoded);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;/head&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;label for=&amp;quot;pubkey&amp;quot;&amp;gt;Public Key&amp;lt;/label&amp;gt;&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;textarea id=&amp;quot;pubkey&amp;quot; rows=&amp;quot;15&amp;quot; cols=&amp;quot;65&amp;quot;&amp;gt;-----BEGIN PUBLIC KEY-----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDY08fkt9d32KHV1JapaZGtk+fL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a7wvxMAdZ0oENhx6HgBisSlDwCgBfRtN5l2iOjKm+eByp7Od24JqIOwgDF6FZ/ol&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CQbnXjzPhG0EOeLnu3AXntzhu9A0yS7b3p+pxGR7EvhIz1xkOS4bNABsAgF7Y5Zu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;B1RpsOZZdxNHGeStBwIDAQAB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-----END PUBLIC KEY-----&amp;lt;/textarea&amp;gt;&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;label for=&amp;quot;input&amp;quot;&amp;gt;Text to encrypt:&amp;lt;/label&amp;gt;&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;textarea id=&amp;quot;input&amp;quot; name=&amp;quot;input&amp;quot; type=&amp;quot;text&amp;quot; rows=4 cols=70&amp;gt;Hello World!&amp;lt;/textarea&amp;gt;&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;input id=&amp;quot;testme&amp;quot; type=&amp;quot;button&amp;quot; value=&amp;quot;RSA Encrypt&amp;quot; /&amp;gt;&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;/body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/digitalbazaar/forge&quot;&gt;https://github.com/digitalbazaar/forge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/digitalbazaar/forge/issues/407&quot;&gt;https://github.com/digitalbazaar/forge/issues/407&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
    <category term="JavaScript" scheme="https://leicode.com/tags/JavaScript/"/>
    
    <category term="NodeJs" scheme="https://leicode.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>CAPTCHA简介与Java实现</title>
    <link href="https://leicode.com/posts/c8f51018/"/>
    <id>https://leicode.com/posts/c8f51018/</id>
    <published>2018-10-16T11:44:32.000Z</published>
    <updated>2018-10-16T12:22:02.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>CAPTCHA(Completely Automated Public Turing test to tell Computers and Humans Apart，简称CAPTCHA)，俗称验证码，是一种区分用户是计算机或人的公共全自动程序。在CAPTCHA测试中，作为服务器的计算机会自动生成一个问题由用户来解答。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。</p><p>目前验证码被广泛应用于网站登录、注册、防刷等处，用于识别和防止自动化程序恶意获取服务和数据。</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>目前大家常见的几类验证码有：</p><ul><li>标准验证码（图片），图片中一般是随机组合的字母和数字，对背景和内容进行扭曲，增加噪点和曲线，使程序难以识别</li><li>根据界面图形，进行鼠标、手指（移动端）交互操作（滑动拼图验证，点选验证）</li><li>No CAPTCHA （Google新一代reCAPTCHA，升级的风险分析技术可以智能无感知的判断人类与机器）</li><li>语音验证（播放一段音频给用户，用户获取信息后提交比对）</li><li>短信、邮箱验证<span id="more"></span></li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>采集用户所处环境信息以及操作信息，提交这些信息给后端服务器进行判断。<br>采集的信息多有：</p><ul><li>插件</li><li>User-agent</li><li>屏幕分辨率</li><li>在captcha的iframe中进行鼠标、键盘、触摸操作的次数和记录</li><li>渲染canvas图像</li><li>Cookies</li><li>用户输入内容</li></ul><p>服务端利用的技术，目前高端的验证码服务，大多会引入海量样本数据，引入深度学习来识别机器与人的行为模式。</p><p>Google的reCAPTCHA首先检测客户端环境，判断使用者是否处于人类的操作环境中。如果检测结果在容错范围内则直接通过测试，否则弹出验证码进行二次认证。</p><p>滑动验证的核心并不是简单的拼接成功就可以过，也不是简单的算一下偏移量就能破解。<br>新的滑块验证码方案，验证码后台针对用户产生的行为轨迹数据进行机器学习建模，结合访问频率、地理位置、历史记录等多个维度信息，快速、准确的返回人机判定结果。</p><p>滑动拼图验证码、图中点选验证码、智能无感知等，其背后的原理除了对滑块起始位置的认知、图中文字及其顺序的认知外，实际还会基于在页面上的操作行为、操作轨迹，以及当前设备的指纹、所运行的环境等维度进行大数据分析，并利用有监督和无监督的机器学习手段，不断升级和优化模型，不断提高破解的成本，保证人机识别的效果。</p><h1 id="验证码服务平台"><a href="#验证码服务平台" class="headerlink" title="验证码服务平台"></a>验证码服务平台</h1><p>极验验证 <a href="http://www.geetest.com/type/">http://www.geetest.com/type/</a><br>网易云 易盾 <a href="http://dun.163.com/trial/sense">http://dun.163.com/trial/sense</a><br>腾讯验证码 <a href="http://open.captcha.qq.com/cap_web/experience-slidepass.html">http://open.captcha.qq.com/cap_web/experience-slidepass.html</a><br>Google reCAPTCHA <a href="https://www.google.com/recaptcha/intro/v3beta.html#">https://www.google.com/recaptcha/intro/v3beta.html#</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;CAPTCHA(Completely Automated Public Turing test to tell Computers and Humans Apart，简称CAPTCHA)，俗称验证码，是一种区分用户是计算机或人的公共全自动程序。在CAPTCHA测试中，作为服务器的计算机会自动生成一个问题由用户来解答。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。&lt;/p&gt;
&lt;p&gt;目前验证码被广泛应用于网站登录、注册、防刷等处，用于识别和防止自动化程序恶意获取服务和数据。&lt;/p&gt;
&lt;h1 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h1&gt;&lt;p&gt;目前大家常见的几类验证码有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准验证码（图片），图片中一般是随机组合的字母和数字，对背景和内容进行扭曲，增加噪点和曲线，使程序难以识别&lt;/li&gt;
&lt;li&gt;根据界面图形，进行鼠标、手指（移动端）交互操作（滑动拼图验证，点选验证）&lt;/li&gt;
&lt;li&gt;No CAPTCHA （Google新一代reCAPTCHA，升级的风险分析技术可以智能无感知的判断人类与机器）&lt;/li&gt;
&lt;li&gt;语音验证（播放一段音频给用户，用户获取信息后提交比对）&lt;/li&gt;
&lt;li&gt;短信、邮箱验证</summary>
    
    
    
    <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="develop" scheme="https://leicode.com/tags/develop/"/>
    
    <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
    <category term="CAPTCHA" scheme="https://leicode.com/tags/CAPTCHA/"/>
    
  </entry>
  
  <entry>
    <title>docker attach的使用与正确退出</title>
    <link href="https://leicode.com/posts/7d17a93a/"/>
    <id>https://leicode.com/posts/7d17a93a/</id>
    <published>2018-10-16T06:41:31.000Z</published>
    <updated>2018-10-16T07:52:04.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sample-Dockerfile"><a href="#Sample-Dockerfile" class="headerlink" title="Sample Dockerfile"></a>Sample Dockerfile</h1><p>后面的讲解，以该Dockerfile构建的镜像为例说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jre-alpine</span><br><span class="line"></span><br><span class="line">MAINTAINER leimingshan</span><br><span class="line"></span><br><span class="line">ADD xxl-sso-server-0.1.1-SNAPSHOT.jar app.jar</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure><p>xxl-sso-server-0.1.1-SNAPSHOT.jar是Spring Boot打包生成的可执行jar，内嵌tomcat容器，直接使用java -jar启动内嵌<br>的tomcat容器并监听8080端口，这里是最简单的一种制作Spring Boot程序镜像的方法，java -jar就是容器内的主进程，如果该<br>进程终止，容器也就相应退出。</p><p>另外一种常见的镜像制作方法，就是加入supervisor来管理进程，稍微重一些，适合管理容器内的多个进程，此时，java等进程是supervisord的子进程，Dockerfile中的命令也要变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;/usr/bin/supervisord&quot;, &quot;-n&quot;, &quot;-c&quot;, &quot;/etc/supervisord.conf&quot;] </span><br></pre></td></tr></table></figure><p>supervisord也是容器内的进程命令，只要supervisord不退出，容器就不会退出。</p><p>Spring Boot相关的内容大家可以自行学习下，这里就不详述了。</p><h1 id="Detached-vs-foreground"><a href="#Detached-vs-foreground" class="headerlink" title="Detached vs foreground"></a>Detached vs foreground</h1><p>Docker run命令运行一个容器的时候，有一个-d选项</p><blockquote><blockquote><p>-d=false: Detached mode: Run container in the background, print new container id</p></blockquote></blockquote><p>detached的意思是让容器在后台运行，同时与你当前终端的STDIN，STDOUT，STDERR分离，然后告诉你一个容器id。<br>执行该命令之后，我们只会看到一个容器id。</p><p>默认不指定-d选项的时候，即-d=false，容器在前台运行，此时容器<br>处于attached状态，或者说是foreground前台模式，容器内进程（一般是ENTRYPOINT指定的运行命令）的STDIN，STDOUT，STDERR<br>会与你当前的命令行终端连接，你就可以直接看到容器内进程执行时候的输出，而你的输入也会重定向到容器内进程。以示例镜像运行产生的容器来说，你的所有输入输出都是和java -jar进程关联的。</p><p>参考：<a href="https://docs.docker.com/engine/reference/run/#detached-vs-foreground">https://docs.docker.com/engine/reference/run/#detached-vs-foreground</a></p><span id="more"></span><h1 id="docker-attach-command"><a href="#docker-attach-command" class="headerlink" title="docker attach command"></a>docker attach command</h1><p>attach命令可以让你attach到一个处于detached状态的容器。<br>以示例来说，我们会重新连接到java -jar进程的输入输出，看到该进程打印到STDOUT和STDERR的内容，如果此时，你属于了CTRL-c，也就是SIGKILL信号会发送给容器，java进程退出，容器也相应退出。</p><p>此处往往让大家感到困惑，我也遇到了这个问题。大多数情况下，我们按CTRL-c，是想结束docker attach这个进程，并不是想结束我们正在运行的attach到的这个容器啊。我们还是想让容器继续运行的呀。</p><p>官方文档说，CTRL-p CTRL-q 按键序列可以实现这个功能啊，其实就是同时按CTRL+p+q，但我发现没用啊。<br>此时我们想detach容器，使容器重新回到detached状态，我这边却无法实现。</p><p>重点来了：<br><a href="https://stackoverflow.com/questions/20145717/how-to-detach-from-a-docker-container">https://stackoverflow.com/questions/20145717/how-to-detach-from-a-docker-container</a></p><p>docker run -t -i → can be detached with ^P^Q and reattached with docker attach<br>docker run -i → cannot be detached with ^P^Q; will disrupt stdin<br>docker run → cannot be detached with ^P^Q; can SIGKILL client; can reattach with docker attach</p><p>参考：<a href="https://docs.docker.com/engine/reference/commandline/attach/">https://docs.docker.com/engine/reference/commandline/attach/</a></p><p>这里就很明显的，只有在run的时候用了-it，才可以用CTRL-p CTRL-q的按键序列进行detach。</p><p>原因是什么呢，这里就涉及到tty和docker tty的许多知识了，后面的文章再详细解释吧。</p><h1 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h1><p>想看到容器的STDOUT和STDERR，并不需要attach到容器上，docker logs命令完全可以满足需求。</p><p>参考：<a href="https://docs.docker.com/engine/reference/commandline/logs/">https://docs.docker.com/engine/reference/commandline/logs/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Sample-Dockerfile&quot;&gt;&lt;a href=&quot;#Sample-Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;Sample Dockerfile&quot;&gt;&lt;/a&gt;Sample Dockerfile&lt;/h1&gt;&lt;p&gt;后面的讲解，以该Dockerfile构建的镜像为例说明。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FROM openjdk:8-jre-alpine&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MAINTAINER leimingshan&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ADD xxl-sso-server-0.1.1-SNAPSHOT.jar app.jar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EXPOSE 8080&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ENTRYPOINT [&amp;quot;java&amp;quot;,&amp;quot;-jar&amp;quot;,&amp;quot;/app.jar&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;xxl-sso-server-0.1.1-SNAPSHOT.jar是Spring Boot打包生成的可执行jar，内嵌tomcat容器，直接使用java -jar启动内嵌&lt;br&gt;的tomcat容器并监听8080端口，这里是最简单的一种制作Spring Boot程序镜像的方法，java -jar就是容器内的主进程，如果该&lt;br&gt;进程终止，容器也就相应退出。&lt;/p&gt;
&lt;p&gt;另外一种常见的镜像制作方法，就是加入supervisor来管理进程，稍微重一些，适合管理容器内的多个进程，此时，java等进程是supervisord的子进程，Dockerfile中的命令也要变成&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ENTRYPOINT [&amp;quot;/usr/bin/supervisord&amp;quot;, &amp;quot;-n&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;/etc/supervisord.conf&amp;quot;] &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;supervisord也是容器内的进程命令，只要supervisord不退出，容器就不会退出。&lt;/p&gt;
&lt;p&gt;Spring Boot相关的内容大家可以自行学习下，这里就不详述了。&lt;/p&gt;
&lt;h1 id=&quot;Detached-vs-foreground&quot;&gt;&lt;a href=&quot;#Detached-vs-foreground&quot; class=&quot;headerlink&quot; title=&quot;Detached vs foreground&quot;&gt;&lt;/a&gt;Detached vs foreground&lt;/h1&gt;&lt;p&gt;Docker run命令运行一个容器的时候，有一个-d选项&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;-d=false: Detached mode: Run container in the background, print new container id&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;detached的意思是让容器在后台运行，同时与你当前终端的STDIN，STDOUT，STDERR分离，然后告诉你一个容器id。&lt;br&gt;执行该命令之后，我们只会看到一个容器id。&lt;/p&gt;
&lt;p&gt;默认不指定-d选项的时候，即-d=false，容器在前台运行，此时容器&lt;br&gt;处于attached状态，或者说是foreground前台模式，容器内进程（一般是ENTRYPOINT指定的运行命令）的STDIN，STDOUT，STDERR&lt;br&gt;会与你当前的命令行终端连接，你就可以直接看到容器内进程执行时候的输出，而你的输入也会重定向到容器内进程。以示例镜像运行产生的容器来说，你的所有输入输出都是和java -jar进程关联的。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://docs.docker.com/engine/reference/run/#detached-vs-foreground&quot;&gt;https://docs.docker.com/engine/reference/run/#detached-vs-foreground&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="docker" scheme="https://leicode.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Java Unsafe的应用与发展</title>
    <link href="https://leicode.com/posts/7d6ac8a1/"/>
    <id>https://leicode.com/posts/7d6ac8a1/</id>
    <published>2018-10-09T06:01:29.000Z</published>
    <updated>2018-10-09T07:37:57.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>sun.misc.Unsafe至少从2004年Java1.4开始就存在于Java中了。<br>在Java9发布之前，有传闻说Oracle会在Java9正式发布时移除sun.misc.Unsafe，引起了激烈的争论。<br>因为有不少重要的Java开发库都在底层使用了sum.misc.Unsafe，例如Netty，Neo4J，Spring Framework，Apache Kafka，Apache Storm等。<br>新的替代API成熟之前，直接移除Unsafe是很冒险的一项做法。</p><p><a href="http://openjdk.java.net/jeps/260">JEP 260</a>是Java9中一项重要内容，意在封装那些JDK内部使用的API，而不再提供给外部应用使用。<br>鉴于类似Unsafe这类非常关键而广泛使用的API，目前也没有非常有效的替代方案，暂时得到了保留，因此在JDK9中，我们仍然可以使用Unsafe类，目前没有被内部封装。<br>在JDK9中jdk.internal.misc中也可以找到Unsafe类。</p><p>JDK9中没有被封装的关键内部类有：</p><ul><li>sun.misc.{Signal,SignalHandler}</li><li>sun.misc.Unsafe （许多功能可以通过variable handles实现，后面介绍）</li><li>sun.reflect.ReflectionFactory</li><li>com.sun.nio.file.{ExtendedCopyOption,ExtendedOpenOption, ExtendedWatchEventModifier,SensitivityWatchEventModifier}</li></ul><p>这些类在以后的版本中可能被移除或封装。而非关键类例如sun.misc.BASE64Encoder和sun.misc.BASE64Decoder则直接被移除了。</p><span id="more"></span><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>Unsafe类名的意思就是“不安全的”，警告开发者们一定要慎重使用该类。</p><p>我们知道，Java语言是不能直接访问底层硬件的，但为了解决某些问题，还不得不访问底层硬件，Java提供了JNI技术（JNI是Java Native Interface的缩写，它提供了若干的API实现了Java和其他语言的通信）使我们可以通过C、C++这类语言去访问底层硬件。</p><p>Unsafe类通过JNI封装了一些较为底层的方法，但就如它的类名表达的含义一样，警告使用者使用它里面的方法是不安全的、是很危险的。使用Unsafe直接操作内存，是绕过了JVM的内存分配机制的，需要自己手动分配回收内存（熟悉C语言的同学一定很熟悉），以及内存屏障（store load barrier）和CAS这些操作，都是非常危险的操作。所以默认情况下，Unsafe只提供给可信任代码（被BootstrapClassLoader加载的类，也就是说只能被rt.jar包里面的类）使用。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>开发者自己编写的类是由AppClassLoader加载的，如果尝试调用Unsafe.getUnsafe()来获得Unsafe的实例的话，你会遇到一个SecurityException的异常，因为前面提到，只有可信任代码（例如JDK中的Atomic相关类）才能这样直接获取Unsafe实例。<br>JDK8之前只能通过反射获取实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">f.setAccessible(true);</span><br><span class="line">Unsafe unsafe = (Unsafe) f.get(null);</span><br></pre></td></tr></table></figure><p>JDK9中其实已经没有了上述限制，参考Unsafe源码对比。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package jdk.internal.misc;</span><br><span class="line"></span><br><span class="line">import jdk.internal.HotSpotIntrinsicCandidate;</span><br><span class="line">import jdk.internal.vm.annotation.ForceInline;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> */</span><br><span class="line">public final class Unsafe &#123;</span><br><span class="line"></span><br><span class="line">    private static native void registerNatives();</span><br><span class="line">    static &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Unsafe() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static final Unsafe theUnsafe = new Unsafe();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Provides the caller with the capability of performing unsafe</span><br><span class="line">     * operations.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The returned &#123;@code Unsafe&#125; object should be carefully guarded</span><br><span class="line">     * by the caller, since it can be used to read and write data at arbitrary</span><br><span class="line">     * memory addresses.  It must never be passed to untrusted code.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Most methods in this class are very low-level, and correspond to a</span><br><span class="line">     * small number of hardware instructions (on typical machines).  Compilers</span><br><span class="line">     * are encouraged to optimize these methods accordingly.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Here is a suggested idiom for using unsafe operations:</span><br><span class="line">     *</span><br><span class="line">     * &lt;pre&gt; &#123;@code</span><br><span class="line">     * class MyTrustedClass &#123;</span><br><span class="line">     *   private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">     *   ...</span><br><span class="line">     *   private long myCountAddress = ...;</span><br><span class="line">     *   public int getCount() &#123; return unsafe.getByte(myCountAddress); &#125;</span><br><span class="line">     * &#125;&#125;&lt;/pre&gt;</span><br><span class="line">     *</span><br><span class="line">     * (It may assist compilers to make the local variable &#123;@code final&#125;.)</span><br><span class="line">     */</span><br><span class="line">    public static Unsafe getUnsafe() &#123;</span><br><span class="line">        return theUnsafe;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>JDK1.9之前的sun.misc.Unsafe</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package sun.misc;</span><br><span class="line"></span><br><span class="line">import jdk.internal.vm.annotation.ForceInline;</span><br><span class="line">import jdk.internal.misc.VM;</span><br><span class="line">import jdk.internal.ref.Cleaner;</span><br><span class="line">import jdk.internal.reflect.CallerSensitive;</span><br><span class="line">import jdk.internal.reflect.Reflection;</span><br><span class="line">import sun.nio.ch.DirectBuffer;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public final class Unsafe &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Reflection.registerMethodsToFilter(Unsafe.class, &quot;getUnsafe&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Unsafe() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static final Unsafe theUnsafe = new Unsafe();</span><br><span class="line">    private static final jdk.internal.misc.Unsafe theInternalUnsafe = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Provides the caller with the capability of performing unsafe</span><br><span class="line">     * operations.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The returned &#123;@code Unsafe&#125; object should be carefully guarded</span><br><span class="line">     * by the caller, since it can be used to read and write data at arbitrary</span><br><span class="line">     * memory addresses.  It must never be passed to untrusted code.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Most methods in this class are very low-level, and correspond to a</span><br><span class="line">     * small number of hardware instructions (on typical machines).  Compilers</span><br><span class="line">     * are encouraged to optimize these methods accordingly.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Here is a suggested idiom for using unsafe operations:</span><br><span class="line">     *</span><br><span class="line">     * &lt;pre&gt; &#123;@code</span><br><span class="line">     * class MyTrustedClass &#123;</span><br><span class="line">     *   private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">     *   ...</span><br><span class="line">     *   private long myCountAddress = ...;</span><br><span class="line">     *   public int getCount() &#123; return unsafe.getByte(myCountAddress); &#125;</span><br><span class="line">     * &#125;&#125;&lt;/pre&gt;</span><br><span class="line">     *</span><br><span class="line">     * (It may assist compilers to make the local variable &#123;@code final&#125;.)</span><br><span class="line">     *</span><br><span class="line">     * @throws  SecurityException if the class loader of the caller</span><br><span class="line">     *          class is not in the system domain in which all permissions</span><br><span class="line">     *          are granted.</span><br><span class="line">     */</span><br><span class="line">    @CallerSensitive</span><br><span class="line">    public static Unsafe getUnsafe() &#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        if (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">            throw new SecurityException(&quot;Unsafe&quot;);</span><br><span class="line">        return theUnsafe;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="未来的替代者Variable-Handles"><a href="#未来的替代者Variable-Handles" class="headerlink" title="未来的替代者Variable Handles"></a>未来的替代者Variable Handles</h1><p><a href="https://www.voxxed.com/2016/11/java-9-series-variable-handles/">https://www.voxxed.com/2016/11/java-9-series-variable-handles/</a><br>java.lang.invoke.VarHandle</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://www.jianshu.com/p/54cc20a87502">https://www.jianshu.com/p/54cc20a87502</a><br><a href="https://blog.csdn.net/luzheqi/article/details/79097682">https://blog.csdn.net/luzheqi/article/details/79097682</a><br><a href="http://ifeve.com/java-9-sun-misc-unsafe/comment-page-1/">http://ifeve.com/java-9-sun-misc-unsafe/comment-page-1/</a><br><a href="https://www.zybuluo.com/kiraSally/note/867462">https://www.zybuluo.com/kiraSally/note/867462</a><br><a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-F7696E02-A1FB-4D5A-B1F2-89E7007D4096">https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-F7696E02-A1FB-4D5A-B1F2-89E7007D4096</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;历史&quot;&gt;&lt;a href=&quot;#历史&quot; class=&quot;headerlink&quot; title=&quot;历史&quot;&gt;&lt;/a&gt;历史&lt;/h1&gt;&lt;p&gt;sun.misc.Unsafe至少从2004年Java1.4开始就存在于Java中了。&lt;br&gt;在Java9发布之前，有传闻说Oracle会在Java9正式发布时移除sun.misc.Unsafe，引起了激烈的争论。&lt;br&gt;因为有不少重要的Java开发库都在底层使用了sum.misc.Unsafe，例如Netty，Neo4J，Spring Framework，Apache Kafka，Apache Storm等。&lt;br&gt;新的替代API成熟之前，直接移除Unsafe是很冒险的一项做法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://openjdk.java.net/jeps/260&quot;&gt;JEP 260&lt;/a&gt;是Java9中一项重要内容，意在封装那些JDK内部使用的API，而不再提供给外部应用使用。&lt;br&gt;鉴于类似Unsafe这类非常关键而广泛使用的API，目前也没有非常有效的替代方案，暂时得到了保留，因此在JDK9中，我们仍然可以使用Unsafe类，目前没有被内部封装。&lt;br&gt;在JDK9中jdk.internal.misc中也可以找到Unsafe类。&lt;/p&gt;
&lt;p&gt;JDK9中没有被封装的关键内部类有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sun.misc.{Signal,SignalHandler}&lt;/li&gt;
&lt;li&gt;sun.misc.Unsafe （许多功能可以通过variable handles实现，后面介绍）&lt;/li&gt;
&lt;li&gt;sun.reflect.ReflectionFactory&lt;/li&gt;
&lt;li&gt;com.sun.nio.file.{ExtendedCopyOption,ExtendedOpenOption, ExtendedWatchEventModifier,SensitivityWatchEventModifier}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些类在以后的版本中可能被移除或封装。而非关键类例如sun.misc.BASE64Encoder和sun.misc.BASE64Decoder则直接被移除了。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK11已正式发布</title>
    <link href="https://leicode.com/posts/df008f1/"/>
    <id>https://leicode.com/posts/df008f1/</id>
    <published>2018-09-29T03:01:11.000Z</published>
    <updated>2018-09-29T08:13:08.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正式发布"><a href="#正式发布" class="headerlink" title="正式发布"></a>正式发布</h1><p>9月25日，Oracle官方宣布Java11(18.9 LTS)正式发布，可在生产环境中使用！<br>Java11是Oracle在2017年宣布新的JDK发布时间表之后，第一个长期支持 - Long Term Support(LTS)版本，非常值得大家关注。<br>如果说之前的Java9和Java10关注度都比较小，基本都被大家忽略的话，Java11可是绝对不容错过的。<br>作为新版发布路线的第一个LTS版本，其重要性和对后面版本的影响都不言而喻，<br>Oracle直到2023年9月都会为Java 11提供技术支持，而补丁和安全警告等扩展支持将持续到2026年。<br>LTS版本每三年发布一次，根据后续的发布计划，下一个LTS版本，应该是Java17，要在3年后的2021年才会与大家见面。</p><p>为了更快地迭代，以及跟进社区反馈，自2018年起，Java的版本发布周期变更为每六个月一次 —— 每半年发布一个大版本，每个季度发布一个中间特性版本，并且承诺不会跳票。<br>通过这样的方式，开发团队可以把一些关键特性尽早合并到JDK之中，以快速得到开发者反馈，在一定程度上避免出现像Java 9这样两次被迫延迟发布的窘况。</p><p>按照官方的说法，新的发布周期会严格遵循时间点，将于每年的3月份和9月份发布。所以Java 11的版本号是18.9(LTS)。</p><p>不过与Java 9和Java 10这两个被称为“功能性版本”不同（两者均只提供半年的技术支持），Java 11不仅提供了长期支持服务，还将作为Java平台的参考实现，并技术支持到2023年9月。</p><span id="more"></span><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html</a> Oracle的商业许可<br><a href="http://jdk.java.net/11">http://jdk.java.net/11</a> OpenJDK, GPLv2 with the Classpath Exception</p><h1 id="License"><a href="#License" class="headerlink" title="License"></a>License</h1><p>在Oracle JDK11的下载页面，有明显的提示信息，指出了Oracle JDK11的<a href="https://www.oracle.com/technetwork/java/javase/terms/license/javase-license.html">许可证</a>情况，需要注意的是</p><blockquote><blockquote><p>You may not:<br>  use the Programs for any data processing or any commercial, production, or internal business purposes other than developing, testing, prototyping, and demonstrating your Application;</p></blockquote></blockquote><p>不允许进行数据处理、商用或在产线使用。只可以用于开发、测试、原型、和应用的演示用途。Oracle JDK已经是商业版本，不是随意免费使用的，若要用在产线环境，需要取得相应授权。</p><p>OpenJDK版本应该是基于GPLv2许可的，也是许多Linux发行版默认使用的，看来以后要拥抱OpenJDK了。</p><h1 id="技术文档"><a href="#技术文档" class="headerlink" title="技术文档"></a>技术文档</h1><p><a href="https://docs.oracle.com/en/java/javase/11/">https://docs.oracle.com/en/java/javase/11/</a></p><h1 id="版本支持情况"><a href="#版本支持情况" class="headerlink" title="版本支持情况"></a>版本支持情况</h1><p>Oracle Java SE的支持路线图，感兴趣的同学可以在<a href="https://www.oracle.com/technetwork/java/javase/eol-135779.html">https://www.oracle.com/technetwork/java/javase/eol-135779.html</a> 查看。<br>对于普通用户和Oracle的商业客户都有些区别，简单了解下就好。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;正式发布&quot;&gt;&lt;a href=&quot;#正式发布&quot; class=&quot;headerlink&quot; title=&quot;正式发布&quot;&gt;&lt;/a&gt;正式发布&lt;/h1&gt;&lt;p&gt;9月25日，Oracle官方宣布Java11(18.9 LTS)正式发布，可在生产环境中使用！&lt;br&gt;Java11是Oracle在2017年宣布新的JDK发布时间表之后，第一个长期支持 - Long Term Support(LTS)版本，非常值得大家关注。&lt;br&gt;如果说之前的Java9和Java10关注度都比较小，基本都被大家忽略的话，Java11可是绝对不容错过的。&lt;br&gt;作为新版发布路线的第一个LTS版本，其重要性和对后面版本的影响都不言而喻，&lt;br&gt;Oracle直到2023年9月都会为Java 11提供技术支持，而补丁和安全警告等扩展支持将持续到2026年。&lt;br&gt;LTS版本每三年发布一次，根据后续的发布计划，下一个LTS版本，应该是Java17，要在3年后的2021年才会与大家见面。&lt;/p&gt;
&lt;p&gt;为了更快地迭代，以及跟进社区反馈，自2018年起，Java的版本发布周期变更为每六个月一次 —— 每半年发布一个大版本，每个季度发布一个中间特性版本，并且承诺不会跳票。&lt;br&gt;通过这样的方式，开发团队可以把一些关键特性尽早合并到JDK之中，以快速得到开发者反馈，在一定程度上避免出现像Java 9这样两次被迫延迟发布的窘况。&lt;/p&gt;
&lt;p&gt;按照官方的说法，新的发布周期会严格遵循时间点，将于每年的3月份和9月份发布。所以Java 11的版本号是18.9(LTS)。&lt;/p&gt;
&lt;p&gt;不过与Java 9和Java 10这两个被称为“功能性版本”不同（两者均只提供半年的技术支持），Java 11不仅提供了长期支持服务，还将作为Java平台的参考实现，并技术支持到2023年9月。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>自建Git服务的几个选择</title>
    <link href="https://leicode.com/posts/a9253739/"/>
    <id>https://leicode.com/posts/a9253739/</id>
    <published>2018-09-12T07:38:51.000Z</published>
    <updated>2018-09-29T03:03:04.310Z</updated>
    
    <content type="html"><![CDATA[<p>两年前比较早的时候，git刚流行起来，私服方案记得只有一个，就是gitlab，gitlab自己提供累死github的公有服务器，也提供自己搭建<br>服务的功能，现在官方还有了docker image，可以说是非常方便了。</p><p>Gitlab的特点：</p><ul><li>优点：功能很全，自带CI持续集成和Issue tracking。</li><li>缺点：比较重，配置要求高。建议独立部署，内存需求比较大。</li></ul><p>最近偶尔看到了几个非常轻量的自建git服务，这里简单记录一下，以后也许会用得到：</p><ol><li>Gogs。<a href="https://gogs.io/%E3%80%82GO%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%EF%BC%8C%E8%B7%A8%E5%B9%B3%E5%8F%B0%EF%BC%8C%E6%94%AF%E6%8C%81docker%E3%80%82">https://gogs.io/。GO语言开发，跨平台，支持docker。</a></li><li>Gitea。Gogs的社区开发维护版本。<a href="https://gitea.io/zh-cn/%E3%80%82">https://gitea.io/zh-cn/。</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;两年前比较早的时候，git刚流行起来，私服方案记得只有一个，就是gitlab，gitlab自己提供累死github的公有服务器，也提供自己搭建&lt;br&gt;服务的功能，现在官方还有了docker image，可以说是非常方便了。&lt;/p&gt;
&lt;p&gt;Gitlab的特点：&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="git" scheme="https://leicode.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo进阶设置</title>
    <link href="https://leicode.com/posts/a62b0c3d/"/>
    <id>https://leicode.com/posts/a62b0c3d/</id>
    <published>2018-09-07T08:21:04.000Z</published>
    <updated>2018-09-29T03:03:58.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态代码压缩"><a href="#静态代码压缩" class="headerlink" title="静态代码压缩"></a>静态代码压缩</h1><p>因为Blog中都是静态页面，基本都可以压缩优化，针对html，css，js，图片进行。<br>这里没必要用gulp去压缩，配置太繁琐，也没法自动化。<br>直接使用<a href="https://github.com/chenzhutian/hexo-all-minifier">hexo-all-minifier</a>这个模块，<br>安装：</p><blockquote><p>npm install hexo-all-minifier –save</p></blockquote><p>增加配置：</p><blockquote><p>all_minifier: true</p></blockquote><p>搞定！</p><h1 id="文章唯一链接"><a href="#文章唯一链接" class="headerlink" title="文章唯一链接"></a>文章唯一链接</h1><p>hexo-abbrlink</p><h1 id="文章字数统计和阅读时长"><a href="#文章字数统计和阅读时长" class="headerlink" title="文章字数统计和阅读时长"></a>文章字数统计和阅读时长</h1><p><a href="https://github.com/theme-next/hexo-symbols-count-time">hexo-symbols-count-time</a><br>可以替代老的hexo-wordcount。</p><h1 id="SEO-搜索引擎收录和优化"><a href="#SEO-搜索引擎收录和优化" class="headerlink" title="SEO-搜索引擎收录和优化"></a>SEO-搜索引擎收录和优化</h1><p>利用插件生成sitemap，hexo自带的两个插件，百度搜索要使用单独的一个。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save     </span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>修改根目录中的_config.yml，url必须要修改成对应的，会体现在sitemap.xml里的url里。增加配置项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>之后hexo重新生成部署，就可以看到两个站点地图的xml文件了。</p><h2 id="Google收录"><a href="#Google收录" class="headerlink" title="Google收录"></a>Google收录</h2><p>Google站点平台：<a href="https://www.google.com/webmasters/">https://www.google.com/webmasters/</a><br>验证站点可以用html文件的方式，html文件放在hexo的source目录后，一定要在开头添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>这样hexo才可以正确处理该文件。</p><p>之后提交sitemap即可，配置比较简单，不再赘述。</p><p>参考资料：</p><ul><li><a href="http://muyunyun.cn/posts/f55182c5/">http://muyunyun.cn/posts/f55182c5/</a></li><li><a href="https://blog.csdn.net/sunshine940326/article/details/70936988">https://blog.csdn.net/sunshine940326/article/details/70936988</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;静态代码压缩&quot;&gt;&lt;a href=&quot;#静态代码压缩&quot; class=&quot;headerlink&quot; title=&quot;静态代码压缩&quot;&gt;&lt;/a&gt;静态代码压缩&lt;/h1&gt;&lt;p&gt;因为Blog中都是静态页面，基本都可以压缩优化，针对html，css，js，图片进行。&lt;br&gt;这里没必要用gulp去压缩，配置太繁琐，也没法自动化。&lt;br&gt;直接使用&lt;a href=&quot;https://github.com/chenzhutian/hexo-all-minifier&quot;&gt;hexo-all-minifier&lt;/a&gt;这个模块，&lt;br&gt;安装：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;npm install hexo-all-minifier –save&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;增加配置：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;all_minifier: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;搞定！&lt;/p&gt;
&lt;h1 id=&quot;文章唯一链接&quot;&gt;&lt;a href=&quot;#文章唯一链接&quot; class=&quot;headerlink&quot; title=&quot;文章唯一链接&quot;&gt;&lt;/a&gt;文章唯一链接&lt;/h1&gt;&lt;p&gt;hexo-abbrlink&lt;/p&gt;
&lt;h1 id=&quot;文章字数统计和阅读时长&quot;&gt;&lt;a href=&quot;#文章字数统计和阅读时长&quot; class=&quot;headerlink&quot; title=&quot;文章字数统计和阅读时长&quot;&gt;&lt;/a&gt;文章字数统计和阅读时长&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/theme-next/hexo-symbols-count-time&quot;&gt;hexo-symbols-count-time&lt;/a&gt;&lt;br&gt;可以替代老的hexo-wordcount。&lt;/p&gt;
&lt;h1 id=&quot;SEO-搜索引擎收录和优化&quot;&gt;&lt;a href=&quot;#SEO-搜索引擎收录和优化&quot; class=&quot;headerlink&quot; title=&quot;SEO-搜索引擎收录和优化&quot;&gt;&lt;/a&gt;SEO-搜索引擎收录和优化&lt;/h1&gt;&lt;p&gt;利用插件生成sitemap，hexo自带的两个插件，百度搜索要使用单独的一个。&lt;/p&gt;</summary>
    
    
    
    <category term="网站" scheme="https://leicode.com/categories/%E7%BD%91%E7%AB%99/"/>
    
    
    <category term="web" scheme="https://leicode.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>JDK11-ZGC</title>
    <link href="https://leicode.com/posts/769720f0/"/>
    <id>https://leicode.com/posts/769720f0/</id>
    <published>2018-09-03T05:52:32.000Z</published>
    <updated>2018-10-09T05:56:16.520Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 11即将于09/25正式发布，包含了诸多新的特性，主要的新特性JEP(JDK Enhancement Proposal 特性增强提议)有17个，参见下表</p><ul><li>181: Nest-Based Access Control</li><li>309: Dynamic Class-File Constants</li><li>315: Improve Aarch64 Intrinsics</li><li>318: Epsilon: A No-Op Garbage Collector</li><li>320: Remove the Java EE and CORBA Modules</li><li>321: HTTP Client (Standard)</li><li>323: Local-Variable Syntax for Lambda Parameters</li><li>324: Key Agreement with Curve25519 and Curve448</li><li>327: Unicode 10</li><li>328: Flight Recorder</li><li>329: ChaCha20 and Poly1305 Cryptographic Algorithms</li><li>330: Launch Single-File Source-Code Programs</li><li>331: Low-Overhead Heap Profiling</li><li>332: Transport Layer Security (TLS) 1.3</li><li>333: ZGC: A Scalable Low-Latency Garbage Collector(Experimental)</li><li>335: Deprecate the Nashorn JavaScript Engine</li><li>336: Deprecate the Pack200 Tools and API</li></ul><p>其中，非常值得大家关注的是JEP-333，ZGC，一个可扩展的低延迟垃圾回收器。ZGC目前仍处于实验阶段，不建议在生产环境使用。<br>目前使用ZGC需要添加JVM参数：-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</p><span id="more"></span><p>ZGC的目标：</p><ul><li>GC停顿(Stop the wordld)时间不会超过10ms</li><li>能够处理从几百MB到几TB大小的JAVA堆</li><li>与G1相比，吞吐量下降不超过15%</li><li>为未来的GC功能和优化利用有色对象指针(colored oops)和加载屏障(load barriers)奠定基础</li><li>初始只支持Linux/x64</li></ul><p>ZGC可以并发执行以下GC任务/阶段：</p><ul><li>标记（Marking）</li><li>引用处理（Reference processing）</li><li>重新分配集的选择（Relocation set selection）</li><li>重分配/压缩（Relocation/Compaction）</li></ul><p>ZGC的特点描述：</p><ul><li>concurrent</li><li>single-generation</li><li>region-based</li><li>NUMA-aware</li></ul><p>GC是Java的主要优势之一。然而，当GC停顿太长，就会开始影响应用的响应时间。消除或者减少GC停顿时长，Java将在更广泛的应用场景中成为一个更有吸引力的平台。<br>此外，现代操作系统中可用内存不断增长，用户和程序员都希望JVM能够以高效的方式充分利用这些内存，并且无需长时间的GC暂停时间。</p><p>ZGC一个并发，基于region，压缩型的垃圾收集器，只有root扫描阶段会STW，因此GC停顿时间不会随着堆的增长和存活对象的增长而变长。</p><p>ZGC的核心设计原则是使用负载屏障（load barrier）与有色指针对象（colored object pointers，colored oops）组合。这使得ZGC能够进行并发操作，比如对象的重定位，Java应用程序线程正在运行时，从Java线程的角度，在Java对象中加载引用字段的行为是会受到负载障碍的影响。除了对象地址以外，有色对象指针包含负载障碍所需的其他信息，用来确定Java线程在使用指针之前是否需要执行某些操作，例如，该对象可能已被重新定位，负载屏障将检测到这种情况并采取合适的行为。</p><p>A core design principle/choice in ZGC is the use of load barriers in combination with colored object pointers (i.e., colored oops). This is what enables ZGC to do concurrent operations, such as object relocation, while Java application threads are running. From a Java thread’s perspective, the act of loading a reference field in a Java object is subject to a load barrier. In addition to an object address, a colored object pointer contains information used by the load barrier to determine if some action needs to be taken before allowing a Java thread to use the pointer. For example, the object might have been relocated, in which case the load barrier will detect the situation and take appropriate action.</p><p>参考文档：<br><a href="http://openjdk.java.net/projects/jdk/11/">JDK 11</a><br><a href="http://openjdk.java.net/jeps/333">JEP 333: ZGC: A Scalable Low-Latency Garbage Collector</a><br><a href="https://wiki.openjdk.java.net/display/zgc/Main">OpenJDK Wiki About ZGC</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JDK 11即将于09/25正式发布，包含了诸多新的特性，主要的新特性JEP(JDK Enhancement Proposal 特性增强提议)有17个，参见下表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;181: Nest-Based Access Control&lt;/li&gt;
&lt;li&gt;309: Dynamic Class-File Constants&lt;/li&gt;
&lt;li&gt;315: Improve Aarch64 Intrinsics&lt;/li&gt;
&lt;li&gt;318: Epsilon: A No-Op Garbage Collector&lt;/li&gt;
&lt;li&gt;320: Remove the Java EE and CORBA Modules&lt;/li&gt;
&lt;li&gt;321: HTTP Client (Standard)&lt;/li&gt;
&lt;li&gt;323: Local-Variable Syntax for Lambda Parameters&lt;/li&gt;
&lt;li&gt;324: Key Agreement with Curve25519 and Curve448&lt;/li&gt;
&lt;li&gt;327: Unicode 10&lt;/li&gt;
&lt;li&gt;328: Flight Recorder&lt;/li&gt;
&lt;li&gt;329: ChaCha20 and Poly1305 Cryptographic Algorithms&lt;/li&gt;
&lt;li&gt;330: Launch Single-File Source-Code Programs&lt;/li&gt;
&lt;li&gt;331: Low-Overhead Heap Profiling&lt;/li&gt;
&lt;li&gt;332: Transport Layer Security (TLS) 1.3&lt;/li&gt;
&lt;li&gt;333: ZGC: A Scalable Low-Latency Garbage Collector(Experimental)&lt;/li&gt;
&lt;li&gt;335: Deprecate the Nashorn JavaScript Engine&lt;/li&gt;
&lt;li&gt;336: Deprecate the Pack200 Tools and API&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，非常值得大家关注的是JEP-333，ZGC，一个可扩展的低延迟垃圾回收器。ZGC目前仍处于实验阶段，不建议在生产环境使用。&lt;br&gt;目前使用ZGC需要添加JVM参数：-XX:+UnlockExperimentalVMOptions -XX:+UseZGC&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>推荐计算机科学书籍</title>
    <link href="https://leicode.com/posts/ba7b25c0/"/>
    <id>https://leicode.com/posts/ba7b25c0/</id>
    <published>2018-08-30T06:01:49.000Z</published>
    <updated>2018-09-07T07:18:29.699Z</updated>
    
    <content type="html"><![CDATA[<p>值得一读的高分计算机书籍：<br><a href="https://www.douban.com/doulist/37472347/?start=0&amp;sort=seq&amp;playable=0&amp;sub_type=">https://www.douban.com/doulist/37472347/?start=0&amp;sort=seq&amp;playable=0&amp;sub_type=</a></p><p>从我的角度来看呢，高级程序员推荐必读</p><h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><p><a href="https://book.douban.com/subject/5407246/">深入理解计算机系统（英文版·第2版）</a></p><h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><p><a href="https://book.douban.com/subject/10746113/">HTTP权威指南</a></p><p><a href="https://book.douban.com/subject/25863515/">图解HTTP</a></p><p><a href="https://book.douban.com/subject/1088054/">TCP/IP详解 卷1：协议</a></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><a href="https://book.douban.com/subject/27096665/">现代操作系统（原书第4版）</a></p><p><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/#book-chapters">Operating Systems</a> 在线免费版本</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><a href="https://book.douban.com/subject/23008813/">高性能MySQL</a></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><a href="https://book.douban.com/subject/19952400/">算法（第4版）</a></p><p><a href="https://book.douban.com/subject/20432061/">算法导论（原书第3版）</a></p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;值得一读的高分计算机书籍：&lt;br&gt;&lt;a href=&quot;https://www.douban.com/doulist/37472347/?start=0&amp;amp;sort=seq&amp;amp;playable=0&amp;amp;sub_type=&quot;&gt;https://www.douban.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch-nested-query</title>
    <link href="https://leicode.com/posts/3f81b35b/"/>
    <id>https://leicode.com/posts/3f81b35b/</id>
    <published>2018-08-27T05:23:35.000Z</published>
    <updated>2018-09-07T07:18:29.697Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch嵌套查询，具体可参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-nested-query.html">Nested Query</a>.</p><p>建议还是要多看多熟悉Elasticsearch的官方文档，比到处去搜强多了。</p><p>简而言之，在对ES doc的多层嵌套对象进行查询的时候，要使用Nested Query，常规查询无效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;nested&quot; : &#123;</span><br><span class="line">            &quot;path&quot; : &quot;obj&quot;,</span><br><span class="line">            &quot;query&quot; : &#123;</span><br><span class="line">                &quot;bool&quot; : &#123;</span><br><span class="line">                    &quot;must&quot; : [</span><br><span class="line">                        &#123; &quot;match&quot; : &#123;&quot;obj.info.name&quot; : &quot;zhangsan&quot;&#125; &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Elasticsearch嵌套查询，具体可参考&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-nested-query.html&quot;&gt;Nested Query</summary>
      
    
    
    
    
    <category term="elasticsearch" scheme="https://leicode.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>RBAC简要设计</title>
    <link href="https://leicode.com/posts/5969db7a/"/>
    <id>https://leicode.com/posts/5969db7a/</id>
    <published>2018-06-07T05:49:24.000Z</published>
    <updated>2018-09-07T07:18:29.698Z</updated>
    
    <content type="html"><![CDATA[<p>Role-Based-Access-Control System Design.<br>比较常见的基于角色的访问控制系统，这次是主要了解和简单设计，不涉及到特别复杂的功能。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>参考文档：<a href="https://blog.csdn.net/yangwenxue_admin/article/details/73936803">https://blog.csdn.net/yangwenxue_admin/article/details/73936803</a></p><p>RBAC（Role-Based Access Control，基于角色的访问控制），就是用户<strong>通过角色与权限进行关联</strong>。</p><p>其主要特点如下：</p><p>一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。<br>这种模型中，用户与角色之间，角色与权限之间，一般是多对多的关系。<br>在此基础上，可以扩展出用户组等实体类型。<br>根据实际需求，可以考虑增加用户组，并对具体权限的类型进行了细分。</p><span id="more"></span><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><p>角色是什么？可以理解为一定数量的权限的集合，权限的载体。例如：一个论坛系统，“超级管理员”、“版主”都是角色。版主可管理版内的帖子、可管理版内的用户等，这些是权限。要给某个用户授予这些权限，不需要直接将权限授予用户，可将“版主”这个角色赋予该用户。  </p><h1 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h1><p>当用户的数量非常大时，要给系统每个用户逐一授权（授角色），是件非常烦琐的事情。这时，就需要给用户分组，每个用户组内有多个用户。</p><p>除了可给用户授权外，还可以给用户组授权。这样一来，用户拥有的所有权限，就是用户个人拥有的权限与该用户所在用户组拥有的权限之和。</p><h1 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h1><p>权限细分出“权限类型”，我们根据它的取值来区分是哪一类权限，进而与特定的表进行关联。如“MENU”表示菜单的访问权限、“RESOURCE”表示可供访问的URL、“FILE”表示文件的修改权限等。 </p><p>这样设计的好处有二：</p><ul><li>不需要区分哪些是权限操作，哪些是资源，（实际上，有时候也不好区分，如菜单，把它理解为资源呢还是功能模块权限呢？）。</li><li>方便扩展，当系统要对新的内容或实体进行权限控制时，我只需要建立一个新的关联表“权限XX关联表”，并确定这类权限的权限类型字符串。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Role-Based-Access-Control System Design.&lt;br&gt;比较常见的基于角色的访问控制系统，这次是主要了解和简单设计，不涉及到特别复杂的功能。&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;参考文档：&lt;a href=&quot;https://blog.csdn.net/yangwenxue_admin/article/details/73936803&quot;&gt;https://blog.csdn.net/yangwenxue_admin/article/details/73936803&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RBAC（Role-Based Access Control，基于角色的访问控制），就是用户&lt;strong&gt;通过角色与权限进行关联&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其主要特点如下：&lt;/p&gt;
&lt;p&gt;一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。&lt;br&gt;这种模型中，用户与角色之间，角色与权限之间，一般是多对多的关系。&lt;br&gt;在此基础上，可以扩展出用户组等实体类型。&lt;br&gt;根据实际需求，可以考虑增加用户组，并对具体权限的类型进行了细分。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MAC &amp; HMAC</title>
    <link href="https://leicode.com/posts/19e9c6b0/"/>
    <id>https://leicode.com/posts/19e9c6b0/</id>
    <published>2018-05-05T05:27:51.000Z</published>
    <updated>2018-09-30T06:23:35.999Z</updated>
    
    <content type="html"><![CDATA[<p>在前一段做安全接入的时候，结合了多种安全和密码学的算法，设计了一套敏感数据传输方案。今天主要介绍的是其中用到的消息认证码（Message authentication code，缩写为MAC）。这里的MAC并不是网卡物理地址的那个MAC，注意区分。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在密码学中，MAC是一小段字节信息，用于验证发送消息的完整性(data integrity)，以及消息的身份认证(确定消息的发送者的身份 - its authenticity)。<br>另一方面来说，MAC可以做到识别内容篡改和内容伪造。<br>回忆一下，Hash算法例如SHA256、MD5等，也可以完成消息完整性的验证，数字签名算法(其实内部也结合了消息散列函数)也可以达到MAC的这两项作用。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>MAC（生成tag）由三个算法组成：</p><ul><li>密钥key生成算法。从密钥空间中选择出来的key是均匀和随机的。</li><li>签名算法。给定Key和消息，生成唯一的tag。</li><li>验证算法。给定Key，tag和消息，验证是否符合。</li></ul><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>MAC方法必须能够抵御chosen-plaintext attacks。<br>简单解释一下：<br>Alice和Bob约定一个只有他们两个知道的MAC key。Eve在监视他们的通信，并且可以获取到他们通信的信息和对应的tags。<br>但是Eve根据得到的这些对应信息，并不能推算出其他消息的有效tag。<br>即使Eve可以说服Alice和Bob发送一些指定的信息，也依旧不能推算出来。<br>在Eve看来，tag是完全随机的字节。</p><span id="more"></span><p>MAC与数字签名的主要不同点，在于MAC在生成和验证阶段使用的是相同的key，接收者和发送者必须实现约定相同的key，才能使用MAC方法进行通信。<br>数字签名则是使用的非对称的公钥和私钥机制，使用私钥进行签名，公钥验证签名。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>HMAC是MAC方法的一种具体实现，使用key和一些特点的Hash函数来生成MAC，常见的有Hmac_MD5，Hmac_SHA1，Hmac_SHA256，Hmac_SHA384，Hmac_SHA512.</p><p>Java代码示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private static final String HMAC_ALGORITHM = &quot;HmacSHA256&quot;;</span><br><span class="line">private static final int HMAC_KEY_LENGTH_BITS = 256;</span><br><span class="line"></span><br><span class="line">public static SecretKey getSecretKey() throws Exception &#123;</span><br><span class="line">    KeyGenerator keyGenerator = KeyGenerator.getInstance(HMAC_ALGORITHM);</span><br><span class="line">    return keyGenerator.generateKey();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static byte[] randomBytes(int length) &#123;</span><br><span class="line">    SecureRandom random = new SecureRandom();</span><br><span class="line">    byte[] b = new byte[length];</span><br><span class="line">    random.nextBytes(b);</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Generate the mac based on HMAC_ALGORITHM</span><br><span class="line"> *</span><br><span class="line"> * @param integrityKey   The key used for hmac</span><br><span class="line"> * @param byteCipherText the cipher text</span><br><span class="line"> *</span><br><span class="line"> * @return A byte array of the HMAC for the given key and ciphertext</span><br><span class="line"> *</span><br><span class="line"> * @throws NoSuchAlgorithmException</span><br><span class="line"> * @throws InvalidKeyException</span><br><span class="line"> */</span><br><span class="line">public static byte[] generateMac(byte[] byteCipherText, SecretKey integrityKey)</span><br><span class="line">        throws NoSuchAlgorithmException, InvalidKeyException &#123;</span><br><span class="line">    // Now compute the mac for later integrity checking</span><br><span class="line">    Mac sha256HMAC = Mac.getInstance(HMAC_ALGORITHM);</span><br><span class="line">    sha256HMAC.init(integrityKey);</span><br><span class="line">    return sha256HMAC.doFinal(byteCipherText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://en.wikipedia.org/wiki/Message_authentication_code">https://en.wikipedia.org/wiki/Message_authentication_code</a><br><a href="https://en.wikipedia.org/wiki/Chosen-plaintext_attack">https://en.wikipedia.org/wiki/Chosen-plaintext_attack</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前一段做安全接入的时候，结合了多种安全和密码学的算法，设计了一套敏感数据传输方案。今天主要介绍的是其中用到的消息认证码（Message authentication code，缩写为MAC）。这里的MAC并不是网卡物理地址的那个MAC，注意区分。&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;在密码学中，MAC是一小段字节信息，用于验证发送消息的完整性(data integrity)，以及消息的身份认证(确定消息的发送者的身份 - its authenticity)。&lt;br&gt;另一方面来说，MAC可以做到识别内容篡改和内容伪造。&lt;br&gt;回忆一下，Hash算法例如SHA256、MD5等，也可以完成消息完整性的验证，数字签名算法(其实内部也结合了消息散列函数)也可以达到MAC的这两项作用。&lt;/p&gt;
&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;MAC（生成tag）由三个算法组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密钥key生成算法。从密钥空间中选择出来的key是均匀和随机的。&lt;/li&gt;
&lt;li&gt;签名算法。给定Key和消息，生成唯一的tag。&lt;/li&gt;
&lt;li&gt;验证算法。给定Key，tag和消息，验证是否符合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;安全&quot;&gt;&lt;a href=&quot;#安全&quot; class=&quot;headerlink&quot; title=&quot;安全&quot;&gt;&lt;/a&gt;安全&lt;/h1&gt;&lt;p&gt;MAC方法必须能够抵御chosen-plaintext attacks。&lt;br&gt;简单解释一下：&lt;br&gt;Alice和Bob约定一个只有他们两个知道的MAC key。Eve在监视他们的通信，并且可以获取到他们通信的信息和对应的tags。&lt;br&gt;但是Eve根据得到的这些对应信息，并不能推算出其他消息的有效tag。&lt;br&gt;即使Eve可以说服Alice和Bob发送一些指定的信息，也依旧不能推算出来。&lt;br&gt;在Eve看来，tag是完全随机的字节。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="develop" scheme="https://leicode.com/tags/develop/"/>
    
    <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
  </entry>
  
</feed>
