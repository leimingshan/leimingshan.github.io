<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mingshan Lei&#39;s Blog</title>
  
  <subtitle>Tech Share</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leicode.com/"/>
  <updated>2018-09-07T08:48:17.475Z</updated>
  <id>https://leicode.com/</id>
  
  <author>
    <name>Mingshan Lei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo进阶设置</title>
    <link href="https://leicode.com/posts/a62b0c3d/"/>
    <id>https://leicode.com/posts/a62b0c3d/</id>
    <published>2018-09-07T08:21:04.000Z</published>
    <updated>2018-09-07T08:48:17.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态代码压缩"><a href="#静态代码压缩" class="headerlink" title="静态代码压缩"></a>静态代码压缩</h1><p>因为Blog中都是静态页面，基本都可以压缩优化，针对html，css，js，图片进行。<br>这里没必要用gulp去压缩，配置太繁琐，也没法自动化。<br>直接使用<a href="https://github.com/chenzhutian/hexo-all-minifier" target="_blank" rel="noopener">hexo-all-minifier</a>这个模块，<br>安装：</p><blockquote><p>npm install hexo-all-minifier –save</p></blockquote><p>增加配置：</p><blockquote><p>all_minifier: true</p></blockquote><p>搞定！</p><h1 id="文章唯一链接"><a href="#文章唯一链接" class="headerlink" title="文章唯一链接"></a>文章唯一链接</h1><p>hexo-abbrlink</p><h1 id="文章字数统计和阅读时长"><a href="#文章字数统计和阅读时长" class="headerlink" title="文章字数统计和阅读时长"></a>文章字数统计和阅读时长</h1><p><a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">hexo-symbols-count-time</a><br>可以替代老的hexo-wordcount。</p><p>参考资料：</p><ul><li><a href="http://muyunyun.cn/posts/f55182c5/" target="_blank" rel="noopener">http://muyunyun.cn/posts/f55182c5/</a></li><li><a href="https://blog.csdn.net/sunshine940326/article/details/70936988" target="_blank" rel="noopener">https://blog.csdn.net/sunshine940326/article/details/70936988</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;静态代码压缩&quot;&gt;&lt;a href=&quot;#静态代码压缩&quot; class=&quot;headerlink&quot; title=&quot;静态代码压缩&quot;&gt;&lt;/a&gt;静态代码压缩&lt;/h1&gt;&lt;p&gt;因为Blog中都是静态页面，基本都可以压缩优化，针对html，css，js，图片进行。&lt;br&gt;这里没必要用g
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDK11-ZGC</title>
    <link href="https://leicode.com/posts/769720f0/"/>
    <id>https://leicode.com/posts/769720f0/</id>
    <published>2018-09-03T05:52:32.000Z</published>
    <updated>2018-09-07T07:18:29.700Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 11即将于09/25正式发布，包含了诸多新的特性，主要的新特性JEP(JDK Enhancement Proposal 特性增强提议)有17个，参见下表</p><ul><li>181: Nest-Based Access Control</li><li>309: Dynamic Class-File Constants</li><li>315: Improve Aarch64 Intrinsics</li><li>318: Epsilon: A No-Op Garbage Collector</li><li>320: Remove the Java EE and CORBA Modules</li><li>321: HTTP Client (Standard)</li><li>323: Local-Variable Syntax for Lambda Parameters</li><li>324: Key Agreement with Curve25519 and Curve448</li><li>327: Unicode 10</li><li>328: Flight Recorder</li><li>329: ChaCha20 and Poly1305 Cryptographic Algorithms</li><li>330: Launch Single-File Source-Code Programs</li><li>331: Low-Overhead Heap Profiling</li><li>332: Transport Layer Security (TLS) 1.3</li><li>333: ZGC: A Scalable Low-Latency Garbage Collector(Experimental)</li><li>335: Deprecate the Nashorn JavaScript Engine</li><li>336: Deprecate the Pack200 Tools and API</li></ul><p>其中，非常值得大家关注的是JEP-333，ZGC，一个可扩展的低延迟垃圾回收器。ZGC暂时是实验性质的。<br><a id="more"></a></p><p>ZGC的目标：</p><ul><li>GC停顿(Stop the wordld)时间不应超过10ms</li><li>能够处理从几百MB到几TB大小的JAVA堆</li><li>与G1相比，吞吐量下降不超过15%</li><li>为未来的GC功能和优化利用有色对象指针(colored oops)和加载屏障(load barriers)奠定基础</li><li>初始只支持Linux/x64</li></ul><p>ZGC可以并发执行以下GC任务/阶段：</p><ul><li>标记（Marking）</li><li>引用处理（Reference processing）</li><li>重新分配集的选择（Relocation set selection）</li><li>重分配/压缩（Relocation/Compaction）</li></ul><p>ZGC的特点描述：</p><ul><li>concurrent</li><li>single-generation</li><li>region-based</li><li>NUMA-aware</li></ul><p>ZGC的核心设计原则是使用负载屏障（load barrier）与有色指针对象（colored object pointers，colored oops）组合。这使得ZGC能够进行并发操作，比如对象的重定位，Java应用程序线程正在运行时，从Java线程的角度，在Java对象中加载引用字段的行为是会受到负载障碍的影响。除了对象地址以外，有色对象指针包含负载障碍所需的其他信息，用来确定Java线程在使用指针之前是否需要执行某些操作，例如，该对象可能已被重新定位，负载屏障将检测到这种情况并采取合适的行为。</p><p>A core design principle/choice in ZGC is the use of load barriers in combination with colored object pointers (i.e., colored oops). This is what enables ZGC to do concurrent operations, such as object relocation, while Java application threads are running. From a Java thread’s perspective, the act of loading a reference field in a Java object is subject to a load barrier. In addition to an object address, a colored object pointer contains information used by the load barrier to determine if some action needs to be taken before allowing a Java thread to use the pointer. For example, the object might have been relocated, in which case the load barrier will detect the situation and take appropriate action.</p><p>参考文档：<br><a href="http://openjdk.java.net/projects/jdk/11/" target="_blank" rel="noopener">JDK 11</a><br><a href="http://openjdk.java.net/jeps/333" target="_blank" rel="noopener">JEP 333: ZGC: A Scalable Low-Latency Garbage Collector</a><br><a href="https://wiki.openjdk.java.net/display/zgc/Main" target="_blank" rel="noopener">OpenJDK Wiki About ZGC</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK 11即将于09/25正式发布，包含了诸多新的特性，主要的新特性JEP(JDK Enhancement Proposal 特性增强提议)有17个，参见下表&lt;/p&gt;&lt;ul&gt;&lt;li&gt;181: Nest-Based Access Control&lt;/li&gt;&lt;li&gt;309: Dynamic Class-File Constants&lt;/li&gt;&lt;li&gt;315: Improve Aarch64 Intrinsics&lt;/li&gt;&lt;li&gt;318: Epsilon: A No-Op Garbage Collector&lt;/li&gt;&lt;li&gt;320: Remove the Java EE and CORBA Modules&lt;/li&gt;&lt;li&gt;321: HTTP Client (Standard)&lt;/li&gt;&lt;li&gt;323: Local-Variable Syntax for Lambda Parameters&lt;/li&gt;&lt;li&gt;324: Key Agreement with Curve25519 and Curve448&lt;/li&gt;&lt;li&gt;327: Unicode 10&lt;/li&gt;&lt;li&gt;328: Flight Recorder&lt;/li&gt;&lt;li&gt;329: ChaCha20 and Poly1305 Cryptographic Algorithms&lt;/li&gt;&lt;li&gt;330: Launch Single-File Source-Code Programs&lt;/li&gt;&lt;li&gt;331: Low-Overhead Heap Profiling&lt;/li&gt;&lt;li&gt;332: Transport Layer Security (TLS) 1.3&lt;/li&gt;&lt;li&gt;333: ZGC: A Scalable Low-Latency Garbage Collector(Experimental)&lt;/li&gt;&lt;li&gt;335: Deprecate the Nashorn JavaScript Engine&lt;/li&gt;&lt;li&gt;336: Deprecate the Pack200 Tools and API&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中，非常值得大家关注的是JEP-333，ZGC，一个可扩展的低延迟垃圾回收器。ZGC暂时是实验性质的。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>推荐计算机科学书籍</title>
    <link href="https://leicode.com/posts/ba7b25c0/"/>
    <id>https://leicode.com/posts/ba7b25c0/</id>
    <published>2018-08-30T06:01:49.000Z</published>
    <updated>2018-09-07T07:18:29.699Z</updated>
    
    <content type="html"><![CDATA[<p>值得一读的高分计算机书籍：<br><a href="https://www.douban.com/doulist/37472347/?start=0&amp;sort=seq&amp;playable=0&amp;sub_type=" target="_blank" rel="noopener">https://www.douban.com/doulist/37472347/?start=0&amp;sort=seq&amp;playable=0&amp;sub_type=</a></p><p>从我的角度来看呢，高级程序员推荐必读</p><h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><p><a href="https://book.douban.com/subject/5407246/" target="_blank" rel="noopener">深入理解计算机系统（英文版·第2版）</a></p><h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><p><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">HTTP权威指南</a></p><p><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">图解HTTP</a></p><p><a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">TCP/IP详解 卷1：协议</a></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">现代操作系统（原书第4版）</a></p><p><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/#book-chapters" target="_blank" rel="noopener">Operating Systems</a> 在线免费版本</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener">高性能MySQL</a></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法（第4版）</a></p><p><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">算法导论（原书第3版）</a></p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;值得一读的高分计算机书籍：&lt;br&gt;&lt;a href=&quot;https://www.douban.com/doulist/37472347/?start=0&amp;amp;sort=seq&amp;amp;playable=0&amp;amp;sub_type=&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch-nested-query</title>
    <link href="https://leicode.com/posts/3f81b35b/"/>
    <id>https://leicode.com/posts/3f81b35b/</id>
    <published>2018-08-27T05:23:35.000Z</published>
    <updated>2018-09-07T07:18:29.697Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch嵌套查询，具体可参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-nested-query.html" target="_blank" rel="noopener">Nested Query</a>.</p><p>建议还是要多看多熟悉Elasticsearch的官方文档，比到处去搜强多了。</p><p>简而言之，在对ES doc的多层嵌套对象进行查询的时候，要使用Nested Query，常规查询无效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;nested&quot; : &#123;</span><br><span class="line">            &quot;path&quot; : &quot;obj&quot;,</span><br><span class="line">            &quot;query&quot; : &#123;</span><br><span class="line">                &quot;bool&quot; : &#123;</span><br><span class="line">                    &quot;must&quot; : [</span><br><span class="line">                        &#123; &quot;match&quot; : &#123;&quot;obj.info.name&quot; : &quot;zhangsan&quot;&#125; &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Elasticsearch嵌套查询，具体可参考&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-nested-query.html&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="elasticsearch" scheme="https://leicode.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>RBAC简要设计</title>
    <link href="https://leicode.com/posts/5969db7a/"/>
    <id>https://leicode.com/posts/5969db7a/</id>
    <published>2018-06-07T05:49:24.000Z</published>
    <updated>2018-09-07T07:18:29.698Z</updated>
    
    <content type="html"><![CDATA[<p>Role-Based-Access-Control System Design.<br>比较常见的基于角色的访问控制系统，这次是主要了解和简单设计，不涉及到特别复杂的功能。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>参考文档：<a href="https://blog.csdn.net/yangwenxue_admin/article/details/73936803" target="_blank" rel="noopener">https://blog.csdn.net/yangwenxue_admin/article/details/73936803</a></p><p>RBAC（Role-Based Access Control，基于角色的访问控制），就是用户<strong>通过角色与权限进行关联</strong>。</p><p>其主要特点如下：</p><p>一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。<br>这种模型中，用户与角色之间，角色与权限之间，一般是多对多的关系。<br>在此基础上，可以扩展出用户组等实体类型。<br>根据实际需求，可以考虑增加用户组，并对具体权限的类型进行了细分。<br><a id="more"></a></p><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><p>角色是什么？可以理解为一定数量的权限的集合，权限的载体。例如：一个论坛系统，“超级管理员”、“版主”都是角色。版主可管理版内的帖子、可管理版内的用户等，这些是权限。要给某个用户授予这些权限，不需要直接将权限授予用户，可将“版主”这个角色赋予该用户。</p><h1 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h1><p>当用户的数量非常大时，要给系统每个用户逐一授权（授角色），是件非常烦琐的事情。这时，就需要给用户分组，每个用户组内有多个用户。</p><p>除了可给用户授权外，还可以给用户组授权。这样一来，用户拥有的所有权限，就是用户个人拥有的权限与该用户所在用户组拥有的权限之和。</p><h1 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h1><p>权限细分出“权限类型”，我们根据它的取值来区分是哪一类权限，进而与特定的表进行关联。如“MENU”表示菜单的访问权限、“RESOURCE”表示可供访问的URL、“FILE”表示文件的修改权限等。</p><p>这样设计的好处有二：</p><ul><li>不需要区分哪些是权限操作，哪些是资源，（实际上，有时候也不好区分，如菜单，把它理解为资源呢还是功能模块权限呢？）。</li><li>方便扩展，当系统要对新的内容或实体进行权限控制时，我只需要建立一个新的关联表“权限XX关联表”，并确定这类权限的权限类型字符串。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Role-Based-Access-Control System Design.&lt;br&gt;比较常见的基于角色的访问控制系统，这次是主要了解和简单设计，不涉及到特别复杂的功能。&lt;/p&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;参考文档：&lt;a href=&quot;https://blog.csdn.net/yangwenxue_admin/article/details/73936803&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/yangwenxue_admin/article/details/73936803&lt;/a&gt;&lt;/p&gt;&lt;p&gt;RBAC（Role-Based Access Control，基于角色的访问控制），就是用户&lt;strong&gt;通过角色与权限进行关联&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;其主要特点如下：&lt;/p&gt;&lt;p&gt;一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。&lt;br&gt;这种模型中，用户与角色之间，角色与权限之间，一般是多对多的关系。&lt;br&gt;在此基础上，可以扩展出用户组等实体类型。&lt;br&gt;根据实际需求，可以考虑增加用户组，并对具体权限的类型进行了细分。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于Redis实现的Rate limiter (限流器)</title>
    <link href="https://leicode.com/posts/9e983597/"/>
    <id>https://leicode.com/posts/9e983597/</id>
    <published>2018-04-10T09:46:12.000Z</published>
    <updated>2018-09-07T07:18:29.695Z</updated>
    
    <content type="html"><![CDATA[<p>首先建议大家好好阅读一下官方文章，如何利用incr命令实现一些应用模式（Pattern）。<br><a href="https://redis.io/commands/incr" target="_blank" rel="noopener">INCR命令的介绍与应用</a></p><p>本文不对原文进行大段翻译，主要讲下自己的理解。</p><h1 id="模式：计数器"><a href="#模式：计数器" class="headerlink" title="模式：计数器"></a>模式：计数器</h1><p>Redis原子性自增操作，最明显的应用就是计数器了，类似Java的AtomicInteger。<br>可以结合EXPIRE，INCRBY，GET，SET，DECR等操作做很多很多事情。<br>多命令的情况下要注意事务或者使用Lua script哦。</p><h1 id="模式：Rate-limiter-限流器"><a href="#模式：Rate-limiter-限流器" class="headerlink" title="模式：Rate limiter 限流器"></a>模式：Rate limiter 限流器</h1><h2 id="限流器的应用"><a href="#限流器的应用" class="headerlink" title="限流器的应用"></a>限流器的应用</h2><p>限流器的应用非常广泛，比如Github对外提供了非常丰富的API，但考虑到数据安全和系统资源，对匿名用户和经过认证的用户的请求API频率都是要有限制的。<br>可以看看Github API的<a href="https://developer.github.com/v3/#rate-limiting" target="_blank" rel="noopener">Rate limiting</a>。<br>认证的用户每小时请求次数是5000，没认证的用户每小时只能请求60次，依靠原始IP来区分未认证用户。</p><p>上面介绍了一个很典型的应用场景，如果一个系统对我提供服务，开放API的话，为了防刷和系统资源的平衡，限流器的应用是很有必要的。<br>调用Github API返回结果的时候，response的Header里面都会带有限流的信息，这是一个非常好的设计，大致如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -i https://api.github.com/users/octocat</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Jul 2013 17:27:06 GMT</span><br><span class="line">Status: 200 OK</span><br><span class="line">X-RateLimit-Limit: 60</span><br><span class="line">X-RateLimit-Remaining: 56</span><br><span class="line">X-RateLimit-Reset: 1372700873</span><br></pre></td></tr></table></figure><p></p><p>我在做网关设计中也借鉴过这种设计方式，另外也参考过spring-cloud-zuul微服务网关中的一个<a href="https://github.com/marcosbarbero/spring-cloud-zuul-ratelimit" target="_blank" rel="noopener">API限流库</a>的代码，里面Filter的设计还是很不错的。</p><a id="more"></a><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>针对每个来访IP，限制每秒只能访问10次。</p><h2 id="模式1：最直接的实现"><a href="#模式1：最直接的实现" class="headerlink" title="模式1：最直接的实现"></a>模式1：最直接的实现</h2><p>KEY值的设计会决定你的解决方案。<br>一种是KEY是IP+当前秒数（UNIX时间戳），那么在该秒内的所有访问，都会对这个KEY执行INCR命令，这个KEY在当前秒之后就没用了其实，设置过期时间大于1秒即可。<br>该方案的伪码表示如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION LIMIT_API_CALL(ip)</span><br><span class="line">ts = CURRENT_UNIX_TIME()</span><br><span class="line">keyname = ip+&quot;:&quot;+ts</span><br><span class="line">current = GET(keyname)</span><br><span class="line">IF current != NULL AND current &gt; 10 THEN</span><br><span class="line">    ERROR &quot;too many requests per second&quot;</span><br><span class="line">ELSE</span><br><span class="line">    MULTI</span><br><span class="line">        INCR(keyname,1)</span><br><span class="line">        EXPIRE(keyname,10)</span><br><span class="line">    EXEC</span><br><span class="line">    PERFORM_API_CALL()</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p></p><p>显而易见的，该方案的缺点是系统访问量大时，比如当前秒有10000个IP来访问，Redis中就会出现10000个KEY，虽然有Redis的过期删除，10秒过期就会导致10秒<br>内的所有IP访问的KEY堆积，大量占用Redis的内存。</p><h2 id="模式2：IP为KEY"><a href="#模式2：IP为KEY" class="headerlink" title="模式2：IP为KEY"></a>模式2：IP为KEY</h2><p>这种设计也很直接啊，IP为KEY，过期时间1秒，有IP访问就自增，超过1秒，该KEY就会过期，后面的访问重新生成KEY。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION LIMIT_API_CALL(ip):</span><br><span class="line">current = GET(ip)</span><br><span class="line">IF current != NULL AND current &gt; 10 THEN</span><br><span class="line">    ERROR &quot;too many requests per second&quot;</span><br><span class="line">ELSE</span><br><span class="line">    value = INCR(ip)</span><br><span class="line">    IF value == 1 THEN</span><br><span class="line">        EXPIRE(ip,1)</span><br><span class="line">    END</span><br><span class="line">    PERFORM_API_CALL()</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p></p><p>官网很明确的指出了这里面的竞争条件，假如多个线程访问，都进入了ELSE进行了自增，ip的值就变为2或更大，EXPIRE没有执行，这个KEY就泄露了，永远保存在Redis中，<br>只有后面又遇到相同IP地址的访问。<br>因为有IF判断语句，所以这里不能使用MULTI-EXEC事务，必须使用lua脚本，提升了设计复杂度。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local current</span><br><span class="line">current = redis.call(&quot;incr&quot;,KEYS[1])</span><br><span class="line">if tonumber(current) == 1 then</span><br><span class="line">    redis.call(&quot;expire&quot;,KEYS[1],1)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p></p><h2 id="模式3：新思路使用list"><a href="#模式3：新思路使用list" class="headerlink" title="模式3：新思路使用list"></a>模式3：新思路使用list</h2><p>直接上lua script好了。KEYS[1]就是访问IP，ARGV[2]是超时时间的ms值，这里是1000，ARGV[1]比较随意，可以是访问时间的ms。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (redis.call(&apos;exists&apos;, KEYS[1]) == 0) then </span><br><span class="line">    redis.call(&apos;rpush&apos;, KEYS[1], ARGV[1]);</span><br><span class="line">    return redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[2]); </span><br><span class="line">else</span><br><span class="line">    return redis.call(&apos;rpushx&apos;, KEYS[1], ARGV[1]); </span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p></p><p>先执行LLEN(KEY)，如果超过限制则返回，否则执行LUA脚本。</p><p>之前有个小同事在这里用了KEYS IP*的方式，类似模式1，这里大家要注意，在很多Redis的线上系统中是会禁用KEYS的，因为KEYS会造成系统CPU的使用率骤增，<br>会导致系统不稳定。我直接改成了这个lua script的用法，现在运行的也很不错。</p><p>这个LUA脚本解决了官网说的竞争问题，官网的伪代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION LIMIT_API_CALL(ip)</span><br><span class="line">current = LLEN(ip)</span><br><span class="line">IF current &gt; 10 THEN</span><br><span class="line">    ERROR &quot;too many requests per second&quot;</span><br><span class="line">ELSE</span><br><span class="line">    IF EXISTS(ip) == FALSE</span><br><span class="line">        MULTI</span><br><span class="line">            RPUSH(ip,ip)</span><br><span class="line">            EXPIRE(ip,1)</span><br><span class="line">        EXEC</span><br><span class="line">    ELSE</span><br><span class="line">        RPUSHX(ip,ip)</span><br><span class="line">    END</span><br><span class="line">    PERFORM_API_CALL()</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p></p><p>简单解释下，这里的竞争在IF EXISTS，多个线程同时判断了IF，都进入了IF，准备执行MULTI-EXEC，<br>当然这里只能顺序执行，一个线程执行完之后，另一个线程也执行，EXPIRE以最后执行的线程为准，由于过期时间的改变，会有略微不准确的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先建议大家好好阅读一下官方文章，如何利用incr命令实现一些应用模式（Pattern）。&lt;br&gt;&lt;a href=&quot;https://redis.io/commands/incr&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;INCR命令的介绍与应用&lt;/a&gt;&lt;/p&gt;&lt;p&gt;本文不对原文进行大段翻译，主要讲下自己的理解。&lt;/p&gt;&lt;h1 id=&quot;模式：计数器&quot;&gt;&lt;a href=&quot;#模式：计数器&quot; class=&quot;headerlink&quot; title=&quot;模式：计数器&quot;&gt;&lt;/a&gt;模式：计数器&lt;/h1&gt;&lt;p&gt;Redis原子性自增操作，最明显的应用就是计数器了，类似Java的AtomicInteger。&lt;br&gt;可以结合EXPIRE，INCRBY，GET，SET，DECR等操作做很多很多事情。&lt;br&gt;多命令的情况下要注意事务或者使用Lua script哦。&lt;/p&gt;&lt;h1 id=&quot;模式：Rate-limiter-限流器&quot;&gt;&lt;a href=&quot;#模式：Rate-limiter-限流器&quot; class=&quot;headerlink&quot; title=&quot;模式：Rate limiter 限流器&quot;&gt;&lt;/a&gt;模式：Rate limiter 限流器&lt;/h1&gt;&lt;h2 id=&quot;限流器的应用&quot;&gt;&lt;a href=&quot;#限流器的应用&quot; class=&quot;headerlink&quot; title=&quot;限流器的应用&quot;&gt;&lt;/a&gt;限流器的应用&lt;/h2&gt;&lt;p&gt;限流器的应用非常广泛，比如Github对外提供了非常丰富的API，但考虑到数据安全和系统资源，对匿名用户和经过认证的用户的请求API频率都是要有限制的。&lt;br&gt;可以看看Github API的&lt;a href=&quot;https://developer.github.com/v3/#rate-limiting&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rate limiting&lt;/a&gt;。&lt;br&gt;认证的用户每小时请求次数是5000，没认证的用户每小时只能请求60次，依靠原始IP来区分未认证用户。&lt;/p&gt;&lt;p&gt;上面介绍了一个很典型的应用场景，如果一个系统对我提供服务，开放API的话，为了防刷和系统资源的平衡，限流器的应用是很有必要的。&lt;br&gt;调用Github API返回结果的时候，response的Header里面都会带有限流的信息，这是一个非常好的设计，大致如下：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl -i https://api.github.com/users/octocat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HTTP/1.1 200 OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date: Mon, 01 Jul 2013 17:27:06 GMT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Status: 200 OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X-RateLimit-Limit: 60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X-RateLimit-Remaining: 56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X-RateLimit-Reset: 1372700873&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我在做网关设计中也借鉴过这种设计方式，另外也参考过spring-cloud-zuul微服务网关中的一个&lt;a href=&quot;https://github.com/marcosbarbero/spring-cloud-zuul-ratelimit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;API限流库&lt;/a&gt;的代码，里面Filter的设计还是很不错的。&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="NoSQL" scheme="https://leicode.com/tags/NoSQL/"/>
    
      <category term="Redis" scheme="https://leicode.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统下的唯一ID生成问题</title>
    <link href="https://leicode.com/posts/8a9934c8/"/>
    <id>https://leicode.com/posts/8a9934c8/</id>
    <published>2018-03-06T05:57:14.000Z</published>
    <updated>2018-09-07T07:18:29.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>在一个应用中会产生大量的业务数据，这些数据往往需要一个ID来标记，在关系型数据库中，主键往往就是这个作用。<br>在大多数数据库中，自增的64bit long类型主键，就是用来解决这个问题的。有时，我们必须在应用层控制ID的生成，<br>这时我们就要缓存下最近生成的ID是多少，以此来跟踪生成的序列。</p><p>如果数据库中的数据做了分片（shard，分库分表），那么在一个表中自增的64bit long主键显然不能适用，多个节点下<br>必然会发生碰撞问题。与此类似，当应用分布在多个节点运行的时候，简单在内存缓存最近的一个ID，也同样不能满足需要。<br><a id="more"></a></p><h1 id="分布式环境下的解决方案"><a href="#分布式环境下的解决方案" class="headerlink" title="分布式环境下的解决方案"></a>分布式环境下的解决方案</h1><h2 id="中心式"><a href="#中心式" class="headerlink" title="中心式"></a>中心式</h2><h3 id="数据库的中心化自增"><a href="#数据库的中心化自增" class="headerlink" title="数据库的中心化自增"></a>数据库的中心化自增</h3><p><a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Flickr的Ticket Server方案</a><br>MySQL的自增显然不能在多库多表的情况下使用，那使用单库单表呢？</p><p>活用MySQL的REPLACE INTO。</p><blockquote><p>REPLACE works exactly like INSERT, except that if an old row in the table has the same value as a new row for a PRIMARY KEY or a UNIQUE index, the old row is deleted before the new row is inserted.</p></blockquote><p>新建两张表，Tickets32 for 32-bit IDs, and Tickets64 for 64-bit IDs.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `Tickets64` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL auto_increment,</span><br><span class="line">  `stub` char(1) NOT NULL default &apos;&apos;,</span><br><span class="line">  PRIMARY KEY  (`id`),</span><br><span class="line">  UNIQUE KEY `stub` (`stub`)</span><br><span class="line">) ENGINE=MyISAM</span><br></pre></td></tr></table></figure><p>当需要一个新的64bit唯一ID时，执行以下SQL：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO Tickets64 (stub) VALUES (&apos;a&apos;);</span><br><span class="line">SELECT LAST_INSERT_ID();</span><br></pre></td></tr></table></figure><p></p><p>因为是单库，怎么解决单点故障问题呢？把ID的数值分成奇数和偶数，在两台数据库服务器上部署。<br>配置如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TicketServer1:</span><br><span class="line">auto-increment-increment = 2</span><br><span class="line">auto-increment-offset = 1</span><br><span class="line"></span><br><span class="line">TicketServer2:</span><br><span class="line">auto-increment-increment = 2</span><br><span class="line">auto-increment-offset = 2</span><br></pre></td></tr></table></figure><p></p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>若系统中已经依赖了Redis，使用Redis也是很好的选择，加上现在Redis已经有了集群化的高可用方案。<br>Redis的INCR命令，可以直接获取增加后的值。如果需要定制更复杂点的生成算法，使用lua脚本结合多个命令即可，lua脚本可以保证原子性。<br>缺点就是依赖Redis啦，每次获取都有一次远程调用，如果很担忧效率的话，可以一次获取批量的ID。</p><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>zookeeper主要通过其znode数据版本来生成序列号，可以生成32位和64位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号。<br>很少会使用zookeeper来生成唯一ID。性能方面会不太理想，但也算一种思路。</p><h3 id="其他的分布式集群协调器"><a href="#其他的分布式集群协调器" class="headerlink" title="其他的分布式集群协调器"></a>其他的分布式集群协调器</h3><p>在不使用数据库的情况下，通过一个后台服务对外提供高可用的、固定步长标识生成，则需要分布式的集群协调器进行。</p><p>一般的，主流协调器有两类：</p><ul><li>以强一致性为目标的：ZooKeeper为代表</li><li>以最终一致性为目标的：Consul为代表</li></ul><p>ZooKeeper的强一致性，是由Paxos协议保证的；Consul的最终一致性，是由Gossip协议保证的。</p><p>在步长累计型生成算法中，最核心的就是保持一个累计值在整个集群中的「强一致性」。同时，这也会为唯一性标识的生成带来新的形成瓶颈。</p><p>参考：<a href="https://juejin.im/entry/57fe1be1bf22ec0064ad96ce" target="_blank" rel="noopener">https://juejin.im/entry/57fe1be1bf22ec0064ad96ce</a></p><h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>Universally unique identifier (UUID)，有时也被称为globally unique identifier(GUID)。<br>拥有RFC标准，应用非常广泛。</p><p>在微软的相关类库中，直接找GUID就可以了。<br>在Java语言中，可以直接使用java.util.UUID类的randomUUID()静态方法，直接可以得到一个类型4的UUID，<br>这也是最常用最简单的生成方法。</p><p>那么什么是类型4呢，是基于伪随机生成UUID的一种方法类型，具体可以学习下UUID的<a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" target="_blank" rel="noopener">Wiki</a>。</p><p>标准UUID的优势：</p><ul><li>各大编程语言自带实现，编码简单，直接使用。没有其他依赖限制。</li><li>性能好。</li><li>全球唯一，碰撞率极小。</li></ul><p>缺点：</p><ul><li>没有顺序性。</li><li>字符串存储，一般需要36个字符表示，比较占用存储空间。</li><li>随机生成，可读性较低。</li><li>用作数据库主键或作为索引的话，查询效率会比较低。<a href="https://medium.com/@varuntayal/re-design-primary-keys-and-ids-9b9776d442b" target="_blank" rel="noopener">UUID与自增64bit long ID的数据库效率比较</a></li></ul><p>建议仔细阅读以下文档：<br><a href="http://www.ietf.org/rfc/rfc4122.txt" target="_blank" rel="noopener">RFC4122</a><br><a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" target="_blank" rel="noopener">UUID Wiki</a></p><h2 id="Snowflake算法"><a href="#Snowflake算法" class="headerlink" title="Snowflake算法"></a>Snowflake算法</h2><p>Twitter贡献的开源分布式ID生成算法，可以生成一个64bit long型ID。<br><img src="https://i.loli.net/2018/09/06/5b90cb6499eff.png" alt="1081851-20161216164125479-1591675346.png"><br>由于该算法依赖于Twitter的一系列基础设施，已经不再维护了。如果要使用的话，可能需要进行一些改造。</p><p><a href="https://github.com/twitter/snowflake" target="_blank" rel="noopener">Source code</a><br><a href="https://segmentfault.com/a/1190000011282426" target="_blank" rel="noopener">看完这一篇就深入理解了</a></p><p><a href="http://darktea.github.io/notes/2013/12/08/Unique-ID" target="_blank" rel="noopener">其他一些变种的flake算法</a></p><h2 id="MongoDB的ObjectId"><a href="#MongoDB的ObjectId" class="headerlink" title="MongoDB的ObjectId"></a>MongoDB的ObjectId</h2><p>和Snowflake算法类似。它设计成轻量型的，不同的机器都能用全局唯一的同种方法方便地生成。<br>MongoDB从一开始就设计用来作为分布式数据库，处理多个节点是一个核心要求，在分布式环境中也很容易应用。</p><p>其他参考文章：<br><a href="https://medium.com/@varuntayal/what-does-it-take-to-generate-cluster-wide-unique-ids-in-a-distributed-system-d505b9eaa46e" target="_blank" rel="noopener">What does it take to generate cluster wide unique ID’s in a distributed system</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h1&gt;&lt;p&gt;在一个应用中会产生大量的业务数据，这些数据往往需要一个ID来标记，在关系型数据库中，主键往往就是这个作用。&lt;br&gt;在大多数数据库中，自增的64bit long类型主键，就是用来解决这个问题的。有时，我们必须在应用层控制ID的生成，&lt;br&gt;这时我们就要缓存下最近生成的ID是多少，以此来跟踪生成的序列。&lt;/p&gt;&lt;p&gt;如果数据库中的数据做了分片（shard，分库分表），那么在一个表中自增的64bit long主键显然不能适用，多个节点下&lt;br&gt;必然会发生碰撞问题。与此类似，当应用分布在多个节点运行的时候，简单在内存缓存最近的一个ID，也同样不能满足需要。&lt;br&gt;
    
    </summary>
    
      <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="develop" scheme="https://leicode.com/tags/develop/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB-ObjectId</title>
    <link href="https://leicode.com/posts/397fc4ba/"/>
    <id>https://leicode.com/posts/397fc4ba/</id>
    <published>2018-03-04T06:15:35.000Z</published>
    <updated>2018-09-07T07:18:29.692Z</updated>
    
    <content type="html"><![CDATA[<p>对于分布式唯一ID的生成，有几种比较好的思路，划分命名空间并行生成，是现在比较流行的一种方式，例如Twitter提出的非常有名的<br>Snowflake算法。与之类似的是，在很早之前，MongoDB的ObjectId生成算法就是类似的这种思路，在MongoDB的0.9.10(2009年8月24日发布)版本中就已经采用。</p><p>在最新的MongoDB-Java-Driver文档中，可以看到ObjectId的相关API说明。参考资料如下：<br><a href="http://mongodb.github.io/mongo-java-driver/3.8/javadoc/org/bson/types/ObjectId.html" target="_blank" rel="noopener">Class ObjectId</a><br><a href="https://github.com/mongodb/mongo-java-driver/blob/master/bson/src/main/org/bson/types/ObjectId.java" target="_blank" rel="noopener">Source code - ObjectId.java</a><br><a id="more"></a></p><p>具体来说，12字节的MongoDB ObjectId的结构是</p><ul><li>a 4-byte value representing the seconds since the Unix epoch</li><li>a 3-byte machine identifier</li><li>a 2-byte process id</li><li>a 3-byte counter, starting with a random value</li></ul><p>可以看出，最小的划分粒度是 秒*进程实例，<br>对于单个进程来说，每秒的ID容量是最后一个字段的3个字节，24bit，即大约16777216个ID，这个容量已经可以满足大部分情况下的ID生成需求了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于分布式唯一ID的生成，有几种比较好的思路，划分命名空间并行生成，是现在比较流行的一种方式，例如Twitter提出的非常有名的&lt;br&gt;Snowflake算法。与之类似的是，在很早之前，MongoDB的ObjectId生成算法就是类似的这种思路，在MongoDB的0.9.10(2009年8月24日发布)版本中就已经采用。&lt;/p&gt;&lt;p&gt;在最新的MongoDB-Java-Driver文档中，可以看到ObjectId的相关API说明。参考资料如下：&lt;br&gt;&lt;a href=&quot;http://mongodb.github.io/mongo-java-driver/3.8/javadoc/org/bson/types/ObjectId.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Class ObjectId&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/mongodb/mongo-java-driver/blob/master/bson/src/main/org/bson/types/ObjectId.java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Source code - ObjectId.java&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://leicode.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="MongoDB" scheme="https://leicode.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Docker-Basic</title>
    <link href="https://leicode.com/posts/a02e5c6b/"/>
    <id>https://leicode.com/posts/a02e5c6b/</id>
    <published>2018-01-25T07:45:10.000Z</published>
    <updated>2018-09-07T07:18:29.691Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于生产环境的上线部署，都依赖于镜像构建、制作、部署上线运行等操作，作为一名合格的RD，当然不能只局限于在上线平台上进行一顿鼠标操作了，一定要弄懂这些基础设施内部到底在干嘛。因此，对Docker的相关学习也是很有必要的。</p><h1 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h1><p><a href="http://dockone.io/article/783" target="_blank" rel="noopener">http://dockone.io/article/783</a></p><p><a href="http://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html" target="_blank" rel="noopener">http://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html</a></p><p>两篇文章分别是中文和英文原版，建议初学者多读几遍，收获非常大。<br>尤其是对镜像只读层和读写层的理解，非常重要，还有docker各个命令对各层的影响。<br><a id="more"></a></p><h1 id="Docker-run"><a href="#Docker-run" class="headerlink" title="Docker run"></a>Docker run</h1><p><a href="https://docs.docker.com/engine/reference/commandline/run/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/run/</a></p><p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p><p>常用选项：</p><ul><li>–detach , -d Run container in background and print container ID</li><li>–tty , -t Allocate a pseudo-TTY</li><li>–interactive , -i Keep STDIN open even if not attached</li><li>–publish , -p Publish a container’s port(s) to the host</li><li>–volume , -v Bind mount a volume</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// sshd -D 将 sshd 作为前台进程运行，而不是脱离控制台成为后台守护进程。主要用于调试。</span><br><span class="line">// -it 通常一起使用，可以开启一个终端进去交互模式，调试时很有用。</span><br><span class="line">docker run -d -p 2222:22 tomcat:centos /usr/sbin/sshd -D</span><br><span class="line"></span><br><span class="line">docker run -ti -v ~/Downloads:/Downloads tomcat:centos /bin/bash</span><br><span class="line"></span><br><span class="line">docker run -d -p 8000:8080 -p 1098:1099 tomcat:centos /usr/local/sbin/tomcat.sh</span><br><span class="line"></span><br><span class="line">docker run -it -p 8000:8080 -p 1098:1099 tomcat:centos /usr/local/sbin/tomcat.sh</span><br></pre></td></tr></table></figure><h1 id="其他Docker命令"><a href="#其他Docker命令" class="headerlink" title="其他Docker命令"></a>其他Docker命令</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ul><li>docker version</li><li>docker info</li><li>docker stop $(docker ps -aq)</li><li>docker rm $(docker ps -aq)</li><li>docker pull</li><li>docker login</li><li>docerk rmi</li><li>docker images</li></ul><h2 id="镜像类"><a href="#镜像类" class="headerlink" title="镜像类"></a>镜像类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 检索image</span><br><span class="line">$docker search image_name</span><br><span class="line"></span><br><span class="line"># 下载image</span><br><span class="line">$docker pull image_name</span><br><span class="line"></span><br><span class="line"># 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don&apos;t truncate output; -q, --quiet=false Only show numeric IDs</span><br><span class="line">$docker images</span><br><span class="line"></span><br><span class="line"># 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents</span><br><span class="line">$docker rmi image_name</span><br><span class="line"></span><br><span class="line"># 显示一个镜像的历史; --no-trunc=false Don&apos;t truncate output; -q, --quiet=false Only show numeric IDs</span><br><span class="line">$docker history image_name</span><br></pre></td></tr></table></figure><h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 列出当前所有正在运行的container</span><br><span class="line">$docker ps</span><br><span class="line"># 列出所有的container</span><br><span class="line">$docker ps -a</span><br><span class="line"># 列出最近一次启动的container</span><br><span class="line">$docker ps -l</span><br><span class="line"></span><br><span class="line"># 保存对容器的修改; -a, --author=&quot;&quot; Author; -m, --message=&quot;&quot; Commit message  </span><br><span class="line">$docker commit ID new_image_name</span><br><span class="line"></span><br><span class="line"># 删除所有容器</span><br><span class="line">$docker rm `docker ps -a -q`</span><br><span class="line">  </span><br><span class="line"># 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container</span><br><span class="line">$docker rm Name/ID</span><br><span class="line"></span><br><span class="line"># 停止、启动、杀死一个容器</span><br><span class="line">$docker stop Name/ID</span><br><span class="line">$docker start Name/ID</span><br><span class="line">$docker kill Name/ID</span><br><span class="line"></span><br><span class="line"># 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps</span><br><span class="line">$docker logs Name/ID</span><br><span class="line">  </span><br><span class="line"># 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的</span><br><span class="line">$docker diff Name/ID</span><br><span class="line">  </span><br><span class="line"># 显示一个运行的容器里面的进程信息</span><br><span class="line">$docker top Name/ID</span><br><span class="line"></span><br><span class="line"># 从容器里面拷贝文件/目录到本地一个路径  </span><br><span class="line">$docker cp Name:/container_path to_path</span><br><span class="line">$docker cp ID:/container_path to_path</span><br><span class="line"></span><br><span class="line"># 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10</span><br><span class="line">$docker restart Name/ID</span><br><span class="line"></span><br><span class="line"># 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process  </span><br><span class="line">$docker attach ID</span><br></pre></td></tr></table></figure><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>to be continued</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鉴于生产环境的上线部署，都依赖于镜像构建、制作、部署上线运行等操作，作为一名合格的RD，当然不能只局限于在上线平台上进行一顿鼠标操作了，一定要弄懂这些基础设施内部到底在干嘛。因此，对Docker的相关学习也是很有必要的。&lt;/p&gt;&lt;h1 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://dockone.io/article/783&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dockone.io/article/783&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;两篇文章分别是中文和英文原版，建议初学者多读几遍，收获非常大。&lt;br&gt;尤其是对镜像只读层和读写层的理解，非常重要，还有docker各个命令对各层的影响。&lt;br&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://leicode.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Hexo启用Https后设置腾讯公益404的问题</title>
    <link href="https://leicode.com/posts/da5ea02e/"/>
    <id>https://leicode.com/posts/da5ea02e/</id>
    <published>2017-08-30T07:12:16.000Z</published>
    <updated>2018-09-07T07:18:29.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h2><p>执行<br>hexo new page 404</p><h2 id="修改source-404-index-md"><a href="#修改source-404-index-md" class="headerlink" title="修改source/404/index.md"></a>修改source/404/index.md</h2><p>一些老的页面会出现问题，因为启用了Https后，去加载Http的样式表和JS会失败，所以要使用以下的页面代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 404</span><br><span class="line">date: 2018-08-30 14:40:55</span><br><span class="line">---</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-cn&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">  &lt;title&gt;404&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; homePageName=&quot;返回宝贝回家&quot; homePageUrl=&quot;https://www.baobeihuijia.com&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;新建页面&quot;&gt;&lt;a href=&quot;#新建页面&quot; class=&quot;headerlink&quot; title=&quot;新建页面&quot;&gt;&lt;/a&gt;新建页面&lt;/h2&gt;&lt;p&gt;执行&lt;br&gt;hexo new page 404&lt;/p&gt;&lt;h2 id=&quot;修改source-404-index-md&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="网站" scheme="https://leicode.com/categories/%E7%BD%91%E7%AB%99/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo Basic Usage</title>
    <link href="https://leicode.com/posts/f49afeaf/"/>
    <id>https://leicode.com/posts/f49afeaf/</id>
    <published>2016-05-18T06:26:50.000Z</published>
    <updated>2018-09-07T07:18:29.700Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><br><a id="more"></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>工作一年的技术成长总结</title>
    <link href="https://leicode.com/posts/4d806b6d/"/>
    <id>https://leicode.com/posts/4d806b6d/</id>
    <published>2016-04-20T07:25:21.000Z</published>
    <updated>2018-09-07T07:18:29.689Z</updated>
    
    <content type="html"><![CDATA[<p>工作一年多以来，学了不少东西，也尝试了许多新东西，也成长了不少，也许只是一个粗略的记录，也希望提醒自己，还是取得了一些成绩吧，但不能骄傲，还有许多不足之处，技术永无止境，还需要更多的努力。<br><a id="more"></a></p><p>工作初始，接触的是C语言网络编程和后台编程的项目，承担的是整体系统中的一部分，加上之前对Redis的了解，也比较适合在这里使用，在设计的时候也就用上了。因为的自己负责调研的部分，所以许多都可以自己设计，还是很高兴的，在使用Redis的过程中，也简单分析了Redis的代码，以及在Linux下编程的技巧，包括学习Redis的Makefile，对错误和消息的处理等。使用Redis作为缓存队列，也实现了自己想要的效果，当然这里会有更优的解决方案，但是作为自己在项目中的第一个设计，还是基本满意的。</p><p>再后来的项目，大部分的经历就转到Java语言项目和Java Web方面了，也接触了一些项目的框架，修改功能代码等。独当一面的是另外一个基于大数据的演示性项目，将来会把这个搭建在服务器上。这个项目里，我独立完成了项目的Java Web后台设计，使用了包括Spring，Struts，MongoDB，Morphia等技术，独立设计前台HTML和JS等，使用了Bootstrap，Echarts，JQuery，Semantic-ui等。项目的时间比较久，后来还有一些改进方案没来得及实施，但是从我的角度来说，是我的一个大作品。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作一年多以来，学了不少东西，也尝试了许多新东西，也成长了不少，也许只是一个粗略的记录，也希望提醒自己，还是取得了一些成绩吧，但不能骄傲，还有许多不足之处，技术永无止境，还需要更多的努力。&lt;br&gt;
    
    </summary>
    
      <category term="Diary" scheme="https://leicode.com/categories/Diary/"/>
    
    
  </entry>
  
  <entry>
    <title>Gradle使用代理服务器</title>
    <link href="https://leicode.com/posts/4fdca764/"/>
    <id>https://leicode.com/posts/4fdca764/</id>
    <published>2016-03-23T01:03:16.000Z</published>
    <updated>2018-09-07T07:18:29.685Z</updated>
    
    <content type="html"><![CDATA[<p>在国内使用Gradle的时候，由于依赖管理时经常需要从mavenCentral（maven中央仓库）和jCenter中下载lib，速度不稳定，有时还会导致build长时间卡住，有一种方法是使用Gradle的Offline模式，但前提是你已经cache了项目的依赖在本地，不然可能会Build失败，另外就是使用代理服务器，也是一种不错的选择。</p><p><strong>在Gradle中使用代理服务器的方法：</strong></p><ol><li><strong>使用以下命令行参数指定代理服务器。</strong><br><pre class="lang:default decode:true">gradle -Dhttp.proxyHost=yourProxy -Dhttp.proxyPort=yourPort -Dhttp.proxyUser=usernameProxy -Dhttp.proxyPassword=yourPassoword</pre><a id="more"></a></li><li><strong>修改Gradle用户配置文件。</strong>可以在GRADLE_USER_HOME下新建文件gradle.properties，然后设置代理。GRADLE_USER_HOME的路径一般如下:<br>/home/&lt;username&gt;/.gradle/ (Linux)<br>/Users/&lt;username&gt;/.gradle/ (Mac)<br>C:\Users\&lt;username&gt;.gradle\ (Windows)<br><pre class="lang:default decode:true"># Http Proxy<br>systemProp.http.proxyHost=<a href="http://www.somehost.org" target="_blank" rel="noopener">www.somehost.org</a><br>systemProp.http.proxyPort=8080<br>systemProp.http.proxyUser=userid<br>systemProp.http.proxyPassword=password<br>systemProp.http.nonProxyHosts=*.nonproxyrepos.com|localhost</pre></li></ol><h1 id="Https-Proxy"><a href="#Https-Proxy" class="headerlink" title="Https Proxy"></a>Https Proxy</h1><p>systemProp.https.proxyHost=<a href="http://www.somehost.org" target="_blank" rel="noopener">www.somehost.org</a><br>systemProp.https.proxyPort=8080<br>systemProp.https.proxyUser=userid<br>systemProp.https.proxyPassword=password<br>systemProp.https.nonProxyHosts=*.nonproxyrepos.com|localhost<br>参考：</p><ol><li><a href="https://docs.gradle.org/current/userguide/build_environment.html" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/build_environment.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在国内使用Gradle的时候，由于依赖管理时经常需要从mavenCentral（maven中央仓库）和jCenter中下载lib，速度不稳定，有时还会导致build长时间卡住，有一种方法是使用Gradle的Offline模式，但前提是你已经cache了项目的依赖在本地，不然可能会Build失败，另外就是使用代理服务器，也是一种不错的选择。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;在Gradle中使用代理服务器的方法：&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;使用以下命令行参数指定代理服务器。&lt;/strong&gt;&lt;br&gt;&lt;pre class=&quot;lang:default decode:true&quot;&gt;gradle -Dhttp.proxyHost=yourProxy -Dhttp.proxyPort=yourPort -Dhttp.proxyUser=usernameProxy -Dhttp.proxyPassword=yourPassoword&lt;/pre&gt;
    
    </summary>
    
      <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
      <category term="Gradle" scheme="https://leicode.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Bug Tracker</title>
    <link href="https://leicode.com/posts/ca051d68/"/>
    <id>https://leicode.com/posts/ca051d68/</id>
    <published>2016-03-22T14:20:38.000Z</published>
    <updated>2018-09-07T07:18:29.684Z</updated>
    
    <content type="html"><![CDATA[<p>最近在尝试使用一些项目管理工具，之前的文章里提到的代码质量分析工具SonarQube，比较符合使用的期望，效果也不错，还有比较早使用的持续集成工具Jenkins，</p><p>然后是缺陷跟踪工具，Bug Tracker System，比较常用的有：</p><ol><li>Redmine <a href="http://www.redmine.org/" target="_blank" rel="noopener">http://www.redmine.org/</a> 网站本身就是Redmine示例。</li><li>Mantis <a href="http://www.mantisbt.org/" target="_blank" rel="noopener">http://www.mantisbt.org/</a> demo：<a href="http://www.mantisbt.org/bugs/my_view_page.php" target="_blank" rel="noopener">http://www.mantisbt.org/bugs/my_view_page.php</a>。</li><li>Atlassian JIRA <a href="https://www.atlassian.com/software/jira/" target="_blank" rel="noopener">https://www.atlassian.com/software/jira/</a> 应用广泛，有云服务版。</li><li>Bugzilla <a href="https://www.bugzilla.org/" target="_blank" rel="noopener">https://www.bugzilla.org/</a><br>类似的工具还有许多，可以查看wiki百科汇总 <a href="https://en.wikipedia.org/wiki/Comparison_of_issue-tracking_systems" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comparison_of_issue-tracking_systems</a>。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在尝试使用一些项目管理工具，之前的文章里提到的代码质量分析工具SonarQube，比较符合使用的期望，效果也不错，还有比较早使用的持续集成工具Jenkins，&lt;/p&gt;&lt;p&gt;然后是缺陷跟踪工具，Bug Tracker System，比较常用的有：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;R
      
    
    </summary>
    
      <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL database character set encoding</title>
    <link href="https://leicode.com/posts/f528791e/"/>
    <id>https://leicode.com/posts/f528791e/</id>
    <published>2016-03-08T03:28:16.000Z</published>
    <updated>2018-09-07T07:18:29.683Z</updated>
    
    <content type="html"><![CDATA[<p>使用MySQL的时候很可能遇到字符集编码相关的问题，尤其是涉及到数据和程序中有中文字符的时候，如果不注意，可能遇到乱码或一些其他的错误。</p><p>本文详细解释MySQL相关的字符集编码设置和排序规则相关的问题。</p><h1 id="MySQL-Server的默认字符集配置"><a href="#MySQL-Server的默认字符集配置" class="headerlink" title="MySQL Server的默认字符集配置"></a>MySQL Server的默认字符集配置</h1><p>在默认安装MySQL的时候，MySQL Server使用的是英文字符集，服务端的默认配置一般是</p><p><span style="text-decoration:underline">character-set-server=latin1</span></p><p><span style="text-decoration:underline">collation-server =latin1_swedish_ci</span></p><p>注意latin1字符集是不支持中文的。第一行的character-set当然是指字符集，第二行的collation是指对应该字符集的比较和排序规则。</p><p><a href="http://dev.mysql.com/doc/refman/5.7/en/charset-server.html" target="_blank" rel="noopener">charset-server参考手册</a><a id="more"></a></p><p>通过MySQL命令</p><p><pre class="lang:mysql decode:true">mysql&gt; SHOW VARIABLES LIKE ‘character%’;</pre><br>可以查看当前服务端的默认配置。</p><p>如果在新建数据库的时候不指定character-set和collation，那么就会采用以上的服务器端默认值，所以还是推荐大家手动指定。示例如下：</p><p><pre class="lang:mysql decode:true">CREATE DATABASE mydb<br>  DEFAULT CHARACTER SET utf8<br>  DEFAULT COLLATE utf8_general_ci;</pre><br>使用utf8和utf8_general_ci是在中英文应用环境下比较常用的一种设置，排序规则还有utf8_unicode_ci，另外还有编码utf8mb4和对应的排序规则，具体区别会在后面的文章说明。<!--more--></p><h1 id="修改已有数据库的字符编码"><a href="#修改已有数据库的字符编码" class="headerlink" title="修改已有数据库的字符编码"></a>修改已有数据库的字符编码</h1><p>如果之前已经建立好了数据库，需要修改当前数据库的编码，可以使用ALTER DATABASE命令。</p><p>首先查看当前数据库的编码和排序规则；</p><p><pre class="lang:mysql decode:true">mysql&gt; USE mydb;<br>Database changed<br>mysql&gt; SHOW VARIABLES LIKE ‘character_set_database’;<br>+————————+——-+<br>| Variable_name          | Value |<br>+————————+——-+<br>| character_set_database | utf8  |<br>+————————+——-+<br>1 row in set (0.00 sec)</pre></p><p>mysql&gt; mysql&gt; SHOW VARIABLES LIKE ‘collation_database’;<br>+——————–+—————–+<br>| Variable_name | Value |<br>+——————–+—————–+<br>| collation_database | utf8_general_ci |<br>+——————–+—————–+<br>1 row in set (0.01 sec)</p><p>mysql&gt;<br><br>然后就可以根据情况修改为自己需要的编码设置了；</p><p><pre class="lang:mysql decode:true">mysql&gt; ALTER DATABASE databasename CHARACTER SET utf8 COLLATE utf8_general_ci;</pre><br>参考：</p><ul><li><a href="https://dev.mysql.com/doc/refman/5.7/en/charset-database.html" target="_blank" rel="noopener">数据库的字符集</a></li><li>修改具体table编码的方法，<a href="https://dev.mysql.com/doc/refman/5.7/en/charset-unicode-upgrading.html" target="_blank" rel="noopener">charset-unicode-upgrading参考手册</a>。</li></ul><h1 id="修改MySQL的服务端配置"><a href="#修改MySQL的服务端配置" class="headerlink" title="修改MySQL的服务端配置"></a>修改MySQL的服务端配置</h1><p>修改my.cnf配置文件可以修改MySQL Server的默认字符集等设置。以配置文件在/etc/my.cnf（可能根据具体安装情况不同）为例，修改以下几项即可：</p><p><pre class="lang:default decode:true">[client]<br>default-character-set = utf8</pre></p><p>[mysql]<br>default-character-set = utf8</p><p>[mysqld]<br>init-connect = ‘SET NAMES utf8’<br>character-set-server = utf8<br>collation-server = utf8_unicode_ci<br>参考</p><ul><li>配置方法：<a href="http://stackoverflow.com/questions/3513773/change-mysql-default-character-set-to-utf-8-in-my-cnf" target="_blank" rel="noopener">http://stackoverflow.com/questions/3513773/change-mysql-default-character-set-to-utf-8-in-my-cnf</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/charset-connection.html" target="_blank" rel="noopener">SET NAMES的官方解释</a><br>&nbsp;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用MySQL的时候很可能遇到字符集编码相关的问题，尤其是涉及到数据和程序中有中文字符的时候，如果不注意，可能遇到乱码或一些其他的错误。&lt;/p&gt;&lt;p&gt;本文详细解释MySQL相关的字符集编码设置和排序规则相关的问题。&lt;/p&gt;&lt;h1 id=&quot;MySQL-Server的默认字符集配置&quot;&gt;&lt;a href=&quot;#MySQL-Server的默认字符集配置&quot; class=&quot;headerlink&quot; title=&quot;MySQL Server的默认字符集配置&quot;&gt;&lt;/a&gt;MySQL Server的默认字符集配置&lt;/h1&gt;&lt;p&gt;在默认安装MySQL的时候，MySQL Server使用的是英文字符集，服务端的默认配置一般是&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;text-decoration:underline&quot;&gt;character-set-server=latin1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;text-decoration:underline&quot;&gt;collation-server =latin1_swedish_ci&lt;/span&gt;&lt;/p&gt;&lt;p&gt;注意latin1字符集是不支持中文的。第一行的character-set当然是指字符集，第二行的collation是指对应该字符集的比较和排序规则。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/charset-server.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;charset-server参考手册&lt;/a&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://leicode.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://leicode.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Gradle与SonarQube的应用</title>
    <link href="https://leicode.com/posts/68467f3f/"/>
    <id>https://leicode.com/posts/68467f3f/</id>
    <published>2016-03-04T08:19:50.000Z</published>
    <updated>2018-09-07T07:18:29.682Z</updated>
    
    <content type="html"><![CDATA[<p>首先是<a href="http://docs.sonarqube.org/display/SONAR/Analyzing+with+SonarQube+Scanner+for+Gradle" target="_blank" rel="noopener">官方文档</a>。这里使用的是新的Gradle SonarQube plugin，注意与以往的Gradle Sonar和Runner插件区分，官方不推荐使用旧插件。</p><p><a href="https://plugins.gradle.org/plugin/org.sonarqube" target="_blank" rel="noopener">SonarQube插件说明</a></p><p>Github示例可以参考<a href="https://github.com/SonarSource/sonar-examples/tree/master/projects/languages/java/gradle/java-gradle-simple" target="_blank" rel="noopener">java-gradle-simple</a>，注意里面build.gradle脚本的写法，以及如何执行SonarQube的Task。</p><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先是&lt;a href=&quot;http://docs.sonarqube.org/display/SONAR/Analyzing+with+SonarQube+Scanner+for+Gradle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;。
      
    
    </summary>
    
      <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
      <category term="Gradle" scheme="https://leicode.com/tags/Gradle/"/>
    
      <category term="SonarQube" scheme="https://leicode.com/tags/SonarQube/"/>
    
  </entry>
  
  <entry>
    <title>本站开始启用全站Https</title>
    <link href="https://leicode.com/posts/cf97a194/"/>
    <id>https://leicode.com/posts/cf97a194/</id>
    <published>2016-03-04T01:32:44.000Z</published>
    <updated>2018-09-07T07:18:29.684Z</updated>
    
    <content type="html"><![CDATA[<p>从今天起本Blog开始启用全站Https。<br>未来的大趋势嘛，哈哈！</p><p><img src="https://i.loli.net/2018/09/06/5b90c99433408.jpg" alt="30-021604_546.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从今天起本Blog开始启用全站Https。&lt;br&gt;未来的大趋势嘛，哈哈！&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/09/06/5b90c99433408.jpg&quot; alt=&quot;30-021604_546.jpg&quot;&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="网站" scheme="https://leicode.com/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="web" scheme="https://leicode.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins SonarQube的搭配使用</title>
    <link href="https://leicode.com/posts/7a61ee38/"/>
    <id>https://leicode.com/posts/7a61ee38/</id>
    <published>2016-03-04T01:20:14.000Z</published>
    <updated>2018-09-07T07:18:29.682Z</updated>
    
    <content type="html"><![CDATA[<p>Jenkins在Ubuntu环境下的安装配置都比较简单，在安装好Java JDK之后，使用</p><p><pre>sudo apt-get install jenkins</pre><br>即可安装。因为没有用到后台数据库，配置过程一般就是配置端口号，以及Nginx或Apache server的代理即可。</p><p>详细方法可以参考<a href="https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+on+Ubuntu" target="_blank" rel="noopener">官方安装指南</a>。</p><p>接下来就是与代码质量分析平台SonarQube的结合使用，前面已经说明了SonarQube的安装，然后就是利用Jenkins在进行持续集成的过程中，进行代码质量分析、代码覆盖率分析，并将相关数据和报告通知给SonarQube。</p><p>在Jenkins中的“系统管理”-“管理插件”中搜索安装SonarQube Plugin，因为我使用的是Java Gradle工程和JaCoCo测试报告，所以之前也安装了Gradle Plugin和JaCoCo Plugin，这里大家可以根据自己具体的项目选择。<a id="more"></a></p><p>在安装好SonarQube Plugin之后，记得在系统设置中配置SonarQube服务器的相关信息，可以参考下图进行。</p><p><a href="http://www.leimingshan.com/wp-content/uploads/2016/03/SonarQube-Plugin.jpg" target="_blank" rel="noopener"><img src="http://www.leimingshan.com/wp-content/uploads/2016/03/SonarQube-Plugin-300x91.jpg" alt="SonarQube Plugin"></a></p><p>另外注意配置SonarQube scanner，这里可以选择自动安装，或者选择自己安装的目录位置。</p><p><a href="http://www.leimingshan.com/wp-content/uploads/2016/03/SonarQube-Runner.jpg" target="_blank" rel="noopener"><img src="http://www.leimingshan.com/wp-content/uploads/2016/03/SonarQube-Runner-300x51.jpg" alt="SonarQube Runner"></a></p><p>服务器配置好之后，然后就是在具体的项目中配置构建过程，选择“增加构建步骤”中的Invoke Standalone SonarQube Analysis，参考下图。</p><p><a href="http://www.leimingshan.com/wp-content/uploads/2016/03/SonarQube-Analysis.jpg" target="_blank" rel="noopener"><img src="http://www.leimingshan.com/wp-content/uploads/2016/03/SonarQube-Analysis-300x131.jpg" alt="SonarQube Analysis"></a></p><p>具体的配置如下：</p><p><pre class="lang:default decode:true"># required metadata<br>sonar.projectKey=pminer:MongoDB-ImportXMLProfile<br>sonar.projectName=MongoDB-ImportXMLProfile<br>sonar.projectVersion=1.0</pre></p><h1 id="path-to-source-directories-required"><a href="#path-to-source-directories-required" class="headerlink" title="path to source directories (required)"></a>path to source directories (required)</h1><p>sonar.sources=src/main/java</p><h1 id="path-to-test-source-directories-optional"><a href="#path-to-test-source-directories-optional" class="headerlink" title="path to test source directories (optional)"></a>path to test source directories (optional)</h1><p>sonar.tests=src/test/java</p><p>sonar.java.binaries=build/classes</p><p>sonar.language=java</p><p>#Tells SonarQube where the unit tests execution reports are<br>sonar.junit.reportsPath=reports/tests</p><p>#Tells SonarQube where the unit tests code coverage report is<br>sonar.jacoco.reportPath=build/jacoco/test.exec</p><h1 id="Encoding-of-the-source-files"><a href="#Encoding-of-the-source-files" class="headerlink" title="Encoding of the source files"></a>Encoding of the source files</h1><p>sonar.sourceEncoding=UTF-8<br>注意以上的配置要根据自己具体的项目路径配置。</p><p>这样在下次的构建中，就会之前SonarQube的分析任务，并将结果发送给SonarQube服务器，然后访问服务器平台就能看到代码的质量报告。</p><p>参考：<a href="http://docs.sonarqube.org/display/PLUG/Code+Coverage+by+Unit+Tests+for+Java+Project" target="_blank" rel="noopener">http://docs.sonarqube.org/display/PLUG/Code+Coverage+by+Unit+Tests+for+Java+Project</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jenkins在Ubuntu环境下的安装配置都比较简单，在安装好Java JDK之后，使用&lt;/p&gt;&lt;p&gt;&lt;pre&gt;sudo apt-get install jenkins&lt;/pre&gt;&lt;br&gt;即可安装。因为没有用到后台数据库，配置过程一般就是配置端口号，以及Nginx或Apache server的代理即可。&lt;/p&gt;&lt;p&gt;详细方法可以参考&lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+on+Ubuntu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方安装指南&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;接下来就是与代码质量分析平台SonarQube的结合使用，前面已经说明了SonarQube的安装，然后就是利用Jenkins在进行持续集成的过程中，进行代码质量分析、代码覆盖率分析，并将相关数据和报告通知给SonarQube。&lt;/p&gt;&lt;p&gt;在Jenkins中的“系统管理”-“管理插件”中搜索安装SonarQube Plugin，因为我使用的是Java Gradle工程和JaCoCo测试报告，所以之前也安装了Gradle Plugin和JaCoCo Plugin，这里大家可以根据自己具体的项目选择。
    
    </summary>
    
      <category term="Java" scheme="https://leicode.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
      <category term="SonarQube" scheme="https://leicode.com/tags/SonarQube/"/>
    
      <category term="Jenkins" scheme="https://leicode.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>SonarQube-代码质量管理平台的安装</title>
    <link href="https://leicode.com/posts/25a76de9/"/>
    <id>https://leicode.com/posts/25a76de9/</id>
    <published>2016-02-25T05:49:30.000Z</published>
    <updated>2018-09-07T07:18:29.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>JDK，数据库（以下以MySQL为例），操作系统支持Linux和Windows（文章以Linux Ubuntu 14.04为例）。</p><h2 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h2><p>终端进入mysql-client：</p><pre class="lang:default decode:true">mysql -u root -p</pre>执行以下SQL语句建立数据库和相关用户：<pre class="lang:default decode:true">CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;CREATE USER 'sonar' IDENTIFIED BY 'sonar';GRANT ALL ON sonar.* TO 'sonar'@'%' IDENTIFIED BY 'sonar';GRANT ALL ON sonar.* TO 'sonar'@'localhost' IDENTIFIED BY 'sonar';FLUSH PRIVILEGES;</pre><a id="more"></a> ## 下载并解压SonarQube安装包 在[SonarQube官网](http://www.sonarqube.org/downloads/)获取最新的下载地址。<pre class="lang:default decode:true">wget https://sonarsource.bintray.com/Distribution/sonarqube/sonarqube-5.3.zipunzip sonarqube-5.3.zipsudo mv sonarqube-5.3 /usr/local/sonar</pre><h2 id="编辑配置文件sonar-properties"><a href="#编辑配置文件sonar-properties" class="headerlink" title="编辑配置文件sonar.properties"></a>编辑配置文件sonar.properties</h2><p>编辑conf目录下的sonar.properties，主要修改数据库配置和web server配置，取消相应行的注释并编辑为对应的值。</p><pre class="lang:default decode:true">sonar.jdbc.username=sonarsonar.jdbc.password=sonarsonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance</pre>以下的web server配置允许以下地址访问 http://127.0.0.1:9000/sonar<pre class="lang:default decode:true">sonar.web.host=127.0.0.1 #默认是0.0.0.0，绑定本机所有ip地址sonar.web.context=/sonar #默认是空sonar.web.port=9000</pre><h2 id="配置Service运行"><a href="#配置Service运行" class="headerlink" title="配置Service运行"></a>配置Service运行</h2><p>参考<a href="http://docs.sonarqube.org/display/SONAR/Running+SonarQube+as+a+Service+on+Linux" target="_blank" rel="noopener">官方文档</a></p><p>新建/etc/init.d/sonar文件并编辑如下。</p><p><pre class="lang:default decode:true">#!/bin/sh<br>#</pre></p><h1 id="rc-file-for-SonarQube"><a href="#rc-file-for-SonarQube" class="headerlink" title="rc file for SonarQube"></a>rc file for SonarQube</h1><p>#</p><h1 id="chkconfig-345-96-10"><a href="#chkconfig-345-96-10" class="headerlink" title="chkconfig: 345 96 10"></a>chkconfig: 345 96 10</h1><h1 id="description-SonarQube-system-www-sonarsource-org"><a href="#description-SonarQube-system-www-sonarsource-org" class="headerlink" title="description: SonarQube system (www.sonarsource.org)"></a>description: SonarQube system (<a href="http://www.sonarsource.org" target="_blank" rel="noopener">www.sonarsource.org</a>)</h1><p>#</p><h3 id="BEGIN-INIT-INFO"><a href="#BEGIN-INIT-INFO" class="headerlink" title="BEGIN INIT INFO"></a>BEGIN INIT INFO</h3><h1 id="Provides-sonar"><a href="#Provides-sonar" class="headerlink" title="Provides: sonar"></a>Provides: sonar</h1><h1 id="Required-Start-network"><a href="#Required-Start-network" class="headerlink" title="Required-Start: $network"></a>Required-Start: $network</h1><h1 id="Required-Stop-network"><a href="#Required-Stop-network" class="headerlink" title="Required-Stop: $network"></a>Required-Stop: $network</h1><h1 id="Default-Start-3-4-5"><a href="#Default-Start-3-4-5" class="headerlink" title="Default-Start: 3 4 5"></a>Default-Start: 3 4 5</h1><h1 id="Default-Stop-0-1-2-6"><a href="#Default-Stop-0-1-2-6" class="headerlink" title="Default-Stop: 0 1 2 6"></a>Default-Stop: 0 1 2 6</h1><h1 id="Short-Description-SonarQube-system-www-sonarsource-org"><a href="#Short-Description-SonarQube-system-www-sonarsource-org" class="headerlink" title="Short-Description: SonarQube system (www.sonarsource.org)"></a>Short-Description: SonarQube system (<a href="http://www.sonarsource.org" target="_blank" rel="noopener">www.sonarsource.org</a>)</h1><h1 id="Description-SonarQube-system-www-sonarsource-org"><a href="#Description-SonarQube-system-www-sonarsource-org" class="headerlink" title="Description: SonarQube system (www.sonarsource.org)"></a>Description: SonarQube system (<a href="http://www.sonarsource.org" target="_blank" rel="noopener">www.sonarsource.org</a>)</h1><h3 id="END-INIT-INFO"><a href="#END-INIT-INFO" class="headerlink" title="END INIT INFO"></a>END INIT INFO</h3><p>/usr/bin/sonar $*<br>运行以下命令安装服务并运行，注意bin子目录的32位64位区别。</p><p><pre class="lang:default decode:true">sudo ln -s $SONAR_HOME/bin/linux-x86-64/sonar.sh /usr/bin/sonar<br>sudo chmod 755 /etc/init.d/sonar<br>sudo update-rc.d sonar defaults<br>sudo service sonar start</pre><br>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装依赖&quot;&gt;&lt;a href=&quot;#安装依赖&quot; class=&quot;headerlink&quot; title=&quot;安装依赖&quot;&gt;&lt;/a&gt;安装依赖&lt;/h2&gt;&lt;p&gt;JDK，数据库（以下以MySQL为例），操作系统支持Linux和Windows（文章以Linux Ubuntu 14.04为例）。&lt;/p&gt;&lt;h2 id=&quot;数据库配置&quot;&gt;&lt;a href=&quot;#数据库配置&quot; class=&quot;headerlink&quot; title=&quot;数据库配置&quot;&gt;&lt;/a&gt;数据库配置&lt;/h2&gt;&lt;p&gt;终端进入mysql-client：&lt;/p&gt;&lt;pre class=&quot;lang:default decode:true&quot;&gt;mysql -u root -p&lt;/pre&gt;执行以下SQL语句建立数据库和相关用户：&lt;pre class=&quot;lang:default decode:true&quot;&gt;CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;
CREATE USER &#39;sonar&#39; IDENTIFIED BY &#39;sonar&#39;;
GRANT ALL ON sonar.* TO &#39;sonar&#39;@&#39;%&#39; IDENTIFIED BY &#39;sonar&#39;;
GRANT ALL ON sonar.* TO &#39;sonar&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;sonar&#39;;
FLUSH PRIVILEGES;&lt;/pre&gt;
    
    </summary>
    
      <category term="开发" scheme="https://leicode.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://leicode.com/tags/Java/"/>
    
      <category term="SonarQube" scheme="https://leicode.com/tags/SonarQube/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu14.04使用ppa源安装PHP-7</title>
    <link href="https://leicode.com/posts/bf78be32/"/>
    <id>https://leicode.com/posts/bf78be32/</id>
    <published>2016-02-05T06:03:12.000Z</published>
    <updated>2018-09-07T07:18:29.680Z</updated>
    
    <content type="html"><![CDATA[<p>在Ubuntu 14.04下安装PHP除了可以直接从官网下载源码编译安装，也可以PPA源安装。如果读者对编译安装的各种选项和配置方法不是很熟悉的话，则推荐使用这种方法快速安装。</p><p>在安装的时候，这里选择的是比较流行的一位个人作者维护的一个PPA源，具体的使用方法如下：</p><ol><li><p>添加源。</p><pre class="lang:default decode:true">sudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php</pre></li><li><p>如果有之前使用apt-get方法安装的PHP，先删除后再安装PHP7。</p><pre class="lang:default decode:true">sudo apt-get updatesudo apt-get purge php5-common -ysudo apt-get install php7.0 php7.0-fpm php7.0-mysql -ysudo apt-get --purge autoremove -y</pre></li><li><p>如果使用nginx，注意以下配置和相应的用户权限。</p><pre class="lang:default decode:true">fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;</pre></li></ol><p>参考：</p><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-upgrade-to-php-7-on-ubuntu-14-04" target="_blank" rel="noopener">How To Upgrade to PHP 7 on Ubuntu 14.04</a></li><li><a href="http://askubuntu.com/questions/705880/how-to-install-php-7" target="_blank" rel="noopener">How to install PHP 7?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Ubuntu 14.04下安装PHP除了可以直接从官网下载源码编译安装，也可以PPA源安装。如果读者对编译安装的各种选项和配置方法不是很熟悉的话，则推荐使用这种方法快速安装。&lt;/p&gt;&lt;p&gt;在安装的时候，这里选择的是比较流行的一位个人作者维护的一个PPA源，具体的使用方法如
      
    
    </summary>
    
      <category term="Linux" scheme="https://leicode.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://leicode.com/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://leicode.com/tags/Ubuntu/"/>
    
      <category term="PHP" scheme="https://leicode.com/tags/PHP/"/>
    
  </entry>
  
</feed>
